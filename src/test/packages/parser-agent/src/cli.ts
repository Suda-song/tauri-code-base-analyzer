#!/usr/bin/env node

import { Command } from 'commander';
import { extractAllEntities } from './fileWalker';
import { generateReadmeToFile, generateReadme } from './readme-generator';
import fs from 'fs';
import path from 'path';

// åˆ›å»ºå‘½ä»¤è¡Œç¨‹åº
const program = new Command();

program
  .name('parser-agent')
  .description('ä» Vue/TS/TSX é¡¹ç›®ä¸­æå–ä»£ç å®ä½“ä¿¡æ¯')
  .version('1.0.0');

/**
 * ç¡®ä¿ç›®å½•å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»º
 * @param dirPath ç›®å½•è·¯å¾„
 */
function ensureDirectoryExists(dirPath: string): void {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
    console.log(`å·²åˆ›å»ºè¾“å‡ºç›®å½•: ${dirPath}`);
  }
}

/**
 * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°æ˜¾ç¤º
 * @param bytes å­—èŠ‚æ•°
 * @returns æ ¼å¼åŒ–åçš„æ–‡ä»¶å¤§å°å­—ç¬¦ä¸²
 */
function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes';

  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * æ˜¾ç¤ºæå–ç»“æœçš„ç»Ÿè®¡ä¿¡æ¯
 * @param entities æå–çš„å®ä½“æ•°ç»„
 * @param startTime å¼€å§‹æ—¶é—´
 */
function displayExtractionStats(entities: any[], startTime: number): void {
  const endTime = Date.now();
  const duration = endTime - startTime;

  console.log('\n=== æå–ç»Ÿè®¡ä¿¡æ¯ ===');
  console.log(`æ€»å®ä½“æ•°: ${entities.length}`);
  console.log(`æå–è€—æ—¶: ${duration}ms`);

  // æŒ‰ç±»å‹ç»Ÿè®¡å®ä½“
  const typeStats: {[key: string]: number} = {};
  entities.forEach(entity => {
    typeStats[entity.type] = (typeStats[entity.type] || 0) + 1;
  });

  console.log('\nå®ä½“ç±»å‹åˆ†å¸ƒ:');
  Object.entries(typeStats)
    .sort((a, b) => b[1] - a[1])  // æŒ‰æ•°é‡é™åºæ’åˆ—
    .forEach(([type, count]) => {
      const percentage = ((count / entities.length) * 100).toFixed(1);
      console.log(`  ${type}: ${count} (${percentage}%)`);
    });

  // æŒ‰æ–‡ä»¶ç±»å‹ç»Ÿè®¡
  const fileStats: {[key: string]: number} = {};
  entities.forEach(entity => {
    const ext = path.extname(entity.file).toLowerCase() || 'no-ext';
    fileStats[ext] = (fileStats[ext] || 0) + 1;
  });

  console.log('\næ–‡ä»¶ç±»å‹åˆ†å¸ƒ:');
  Object.entries(fileStats)
    .sort((a, b) => b[1] - a[1])
    .forEach(([ext, count]) => {
      console.log(`  ${ext}: ${count} ä¸ªæ–‡ä»¶`);
    });
}

/**
 * è§£æREADMEå†…å®¹ï¼Œè¯†åˆ«è‡ªåŠ¨ç”Ÿæˆçš„éƒ¨åˆ†å’Œç”¨æˆ·ç¼–è¾‘çš„éƒ¨åˆ†
 */
function parseReadmeStructure(content: string): {
  userSections: Map<string, string>;
  autoSections: Set<string>;
  preservedContent: string[];
} {
  const lines = content.split('\n');
  const userSections = new Map<string, string>();
  const autoSections = new Set([
    'ğŸ“Š Project Overview',
    'ğŸ—‚ï¸ Project Directory Structure', 
    'ğŸ“‚ Detailed Directory Analysis',
    'ğŸ“ˆ Project Statistics',
    '## ğŸ“Š é¡¹ç›®æ¦‚è§ˆ',
    '## ğŸ—‚ï¸ é¡¹ç›®ç›®å½•ç»“æ„',
    '## ğŸ“‚ è¯¦ç»†ç›®å½•åˆ†æ',
    '## ğŸ“ˆ é¡¹ç›®ç»Ÿè®¡'
  ]);
  
  let currentSection = '';
  let currentContent: string[] = [];
  let inAutoGeneratedSection = false;
  const preservedContent: string[] = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // æ£€æµ‹æ˜¯å¦æ˜¯æ ‡é¢˜è¡Œ
    if (line.startsWith('##') || line.startsWith('#')) {
      // ä¿å­˜ä¸Šä¸€ä¸ªsection
      if (currentSection && !inAutoGeneratedSection) {
        userSections.set(currentSection, currentContent.join('\n'));
      } else if (!inAutoGeneratedSection) {
        preservedContent.push(...currentContent);
      }
      
      currentSection = line.trim();
      currentContent = [line];
      inAutoGeneratedSection = autoSections.has(currentSection.replace(/^#+\s*/, ''));
    } else {
      currentContent.push(line);
    }
  }
  
  // å¤„ç†æœ€åä¸€ä¸ªsection
  if (currentSection && !inAutoGeneratedSection) {
    userSections.set(currentSection, currentContent.join('\n'));
  } else if (!inAutoGeneratedSection) {
    preservedContent.push(...currentContent);
  }

  return { userSections, autoSections, preservedContent };
}

/**
 * åˆå¹¶æ–°å†…å®¹å’Œç°æœ‰ç”¨æˆ·å†…å®¹
 */
function mergeReadmeContent(
  newContent: string, 
  userSections: Map<string, string>,
  preservedContent: string[]
): string {
  const newLines = newContent.split('\n');
  const result: string[] = [];
  
  let currentSection = '';
  let skipCurrentSection = false;
  
  for (let i = 0; i < newLines.length; i++) {
    const line = newLines[i];
    
    if (line.startsWith('##') || line.startsWith('#')) {
      // ç»“æŸä¸Šä¸€ä¸ªsectionçš„è·³è¿‡çŠ¶æ€
      skipCurrentSection = false;
      currentSection = line.trim();
      
      // æ£€æŸ¥æ˜¯å¦æœ‰ç”¨æˆ·è‡ªå®šä¹‰ç‰ˆæœ¬çš„è¿™ä¸ªsection
      const sectionKey = currentSection.replace(/^#+\s*/, '');
      if (userSections.has(currentSection)) {
        // ä½¿ç”¨ç”¨æˆ·è‡ªå®šä¹‰å†…å®¹
        result.push(userSections.get(currentSection)!);
        skipCurrentSection = true;
        continue;
      }
    }
    
    if (!skipCurrentSection) {
      result.push(line);
    }
  }
  
  // æ·»åŠ ç”¨æˆ·ä¿ç•™çš„å†…å®¹
  if (preservedContent.length > 0) {
    result.push('', '---', '', '## ğŸ“ User Preserved Content', '');
    result.push(...preservedContent);
  }
  
  return result.join('\n');
}

/**
 * æ‰§è¡ŒçœŸæ­£çš„å¢é‡ README æ›´æ–°é€»è¾‘çš„è¾…åŠ©å‡½æ•°
 * @param rootDir é¡¹ç›®æ ¹ç›®å½•
 * @param options å‘½ä»¤é€‰é¡¹
 */
async function executePatchReadme(rootDir: string, options: any): Promise<void> {
  const startTime = Date.now();

  try {
    console.log('=== AI README å¢é‡æ›´æ–°å™¨ ===');
    console.log(`é¡¹ç›®ç›®å½•: ${rootDir}`);
    console.log(`è¾“å‡ºæ–‡ä»¶: ${options.output}`);
    console.log(`æ–‡æ¡£è¯­è¨€: ${options.language}`);
    console.log(`é¢„è§ˆæ¨¡å¼: ${options.preview ? 'æ˜¯' : 'å¦'}`);
    console.log(`å·®å¼‚æ¨¡å¼: ${options.diff ? 'æ˜¯' : 'å¦'}`);
    console.log('=====================================\n');

    // æ£€æŸ¥é¡¹ç›®ç›®å½•æ˜¯å¦å­˜åœ¨
    if (!fs.existsSync(rootDir)) {
      console.error(`âŒ é¡¹ç›®ç›®å½•ä¸å­˜åœ¨: ${rootDir}`);
      process.exit(1);
    }

    // æ™ºèƒ½å¤„ç†è¾“å‡ºè·¯å¾„
    let outputPath: string;
    
    if (!options.output || options.output.trim() === '') {
      // é»˜è®¤è¾“å‡ºåˆ°é¡¹ç›®æ ¹ç›®å½•ï¼Œç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„æ–‡ä»¶å
      const now = new Date();
      const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
      const filename = `readme-${timestamp}.md`;
      outputPath = path.join(rootDir, filename);
      console.log(`ğŸ“ ä½¿ç”¨é»˜è®¤è¾“å‡ºè·¯å¾„ï¼Œç”Ÿæˆæ–‡ä»¶å: ${filename}`);
    } else {
      outputPath = path.isAbsolute(options.output) 
        ? options.output 
        : path.join(rootDir, options.output);

      // æ£€æŸ¥æ˜¯å¦æ˜¯ç›®å½•æˆ–éœ€è¦ç”Ÿæˆæ—¶é—´æˆ³æ–‡ä»¶å
      if (fs.existsSync(outputPath) && fs.statSync(outputPath).isDirectory()) {
        // ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„æ–‡ä»¶å
        const now = new Date();
        const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
        const filename = `readme-${timestamp}.md`;
        outputPath = path.join(outputPath, filename);
        console.log(`ğŸ“ æ£€æµ‹åˆ°ç›®å½•è·¯å¾„ï¼Œè‡ªåŠ¨ç”Ÿæˆæ–‡ä»¶å: ${filename}`);
      } else if (!fs.existsSync(outputPath)) {
        // æ£€æŸ¥çˆ¶ç›®å½•æ˜¯å¦å­˜åœ¨ä¸”æ˜¯ç›®å½•
        const parentDir = path.dirname(outputPath);
        if (fs.existsSync(parentDir) && fs.statSync(parentDir).isDirectory()) {
          const basename = path.basename(options.output);
          if (!basename || basename === '.md' || basename === 'readme.md') {
            // ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„æ–‡ä»¶å
            const now = new Date();
            const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            const filename = `readme-${timestamp}.md`;
            outputPath = path.join(parentDir, filename);
            console.log(`ğŸ“ æ£€æµ‹åˆ°ç›®å½•è·¯å¾„ï¼Œè‡ªåŠ¨ç”Ÿæˆæ–‡ä»¶å: ${filename}`);
          }
        }
      }
    }

    // æ£€æŸ¥ç°æœ‰ README æ–‡ä»¶
    let existingContent = '';
    let hasExistingReadme = false;
    let userSections = new Map<string, string>();
    let preservedContent: string[] = [];
    
    if (fs.existsSync(outputPath)) {
      existingContent = fs.readFileSync(outputPath, 'utf8');
      hasExistingReadme = true;
      console.log(`ğŸ“„ æ£€æµ‹åˆ°ç°æœ‰ README æ–‡ä»¶: ${outputPath}`);
      
      // è§£æç°æœ‰READMEç»“æ„
      const parsed = parseReadmeStructure(existingContent);
      userSections = parsed.userSections;
      preservedContent = parsed.preservedContent;
      
      console.log(`ğŸ“‹ è§£æåˆ° ${userSections.size} ä¸ªç”¨æˆ·è‡ªå®šä¹‰ç« èŠ‚`);
      console.log(`ğŸ“ ä¿ç•™ ${preservedContent.length} è¡Œç”¨æˆ·å†…å®¹`);
    } else {
      console.log(`ğŸ“„ å°†åˆ›å»ºæ–°çš„ README æ–‡ä»¶: ${outputPath}`);
    }

    if (options.verbose) {
      console.log('ğŸ” å¼€å§‹åˆ†æé¡¹ç›®ç»“æ„å˜æ›´...');
    }

    // ç”Ÿæˆæ–°çš„ README å†…å®¹
    console.log('ğŸ“ æ­£åœ¨ç”Ÿæˆæ›´æ–°çš„ README æ–‡æ¡£...');
    
    const newContent = await generateReadme(
      rootDir,
      'engineering-focused', // ä½¿ç”¨å·¥ç¨‹èšç„¦çš„æ¨¡æ¿
      options.language,
      options.custom
    );

    // å¦‚æœæœ‰ç°æœ‰READMEï¼Œè¿›è¡Œæ™ºèƒ½åˆå¹¶
    let finalContent = newContent;
    if (hasExistingReadme && userSections.size > 0) {
      console.log('ğŸ”„ æ­£åœ¨è¿›è¡Œæ™ºèƒ½å†…å®¹åˆå¹¶...');
      finalContent = mergeReadmeContent(newContent, userSections, preservedContent);
      console.log('âœ… ç”¨æˆ·è‡ªå®šä¹‰å†…å®¹å·²ä¿ç•™');
    }

    // å¦‚æœæ˜¯å·®å¼‚æ¨¡å¼ï¼Œæ˜¾ç¤ºå·®å¼‚
    if (options.diff && hasExistingReadme) {
      console.log('\n=== æ–‡æ¡£å˜æ›´å·®å¼‚ ===');
      const oldLines = existingContent.split('\n').length;
      const newLines = finalContent.split('\n').length;
      const sizeDiff = finalContent.length - existingContent.length;
      
      console.log(`ğŸ“Š è¡Œæ•°å˜åŒ–: ${oldLines} â†’ ${newLines} (${newLines - oldLines >= 0 ? '+' : ''}${newLines - oldLines})`);
      console.log(`ğŸ“ å¤§å°å˜åŒ–: ${formatFileSize(existingContent.length)} â†’ ${formatFileSize(finalContent.length)} (${sizeDiff >= 0 ? '+' : ''}${formatFileSize(Math.abs(sizeDiff))})`);
      console.log(`ğŸ”’ ä¿ç•™ç”¨æˆ·ç« èŠ‚: ${userSections.size} ä¸ª`);
      console.log(`ğŸ“ ä¿ç•™ç”¨æˆ·å†…å®¹: ${preservedContent.length} è¡Œ`);
    }

    // é¢„è§ˆæ¨¡å¼
    if (options.preview) {
      console.log('\n=== README å¢é‡æ›´æ–°é¢„è§ˆ ===');
      if (hasExistingReadme) {
        console.log('ğŸ”„ å¢é‡æ›´æ–°æ¨¡å¼ï¼šå°†ä¿ç•™ç”¨æˆ·è‡ªå®šä¹‰å†…å®¹ï¼Œä»…æ›´æ–°è‡ªåŠ¨ç”Ÿæˆéƒ¨åˆ†');
        console.log('\nğŸ“‹ å°†ä¿ç•™çš„ç”¨æˆ·ç« èŠ‚ï¼š');
        userSections.forEach((content, section) => {
          console.log(`  - ${section}`);
        });
      } else {
        console.log('ğŸ“„ æ–°å»ºæ¨¡å¼ï¼šå°†åˆ›å»ºå…¨æ–°çš„READMEæ–‡ä»¶');
      }
      
      console.log('\nğŸ“ é¢„è§ˆå†…å®¹ï¼ˆå‰50è¡Œï¼‰ï¼š');
      console.log(finalContent.split('\n').slice(0, 50).join('\n'));
      console.log('\n... (å†…å®¹æˆªæ–­) ...');
      console.log('\n=== é¢„è§ˆç»“æŸ ===');

      const endTime = Date.now();
      const duration = endTime - startTime;
      console.log(`\nâ±ï¸  ç”Ÿæˆè€—æ—¶: ${duration}ms`);
      console.log('ğŸ’¡ ä½¿ç”¨ --no-preview é€‰é¡¹æ¥å®é™…ä¿å­˜æ›´æ–°');
      
      return;
    }

    // ä¿å­˜æ›´æ–°çš„ README
    fs.writeFileSync(outputPath, finalContent, 'utf8');

    // æ˜¾ç¤ºæ›´æ–°ç»“æœ
    const endTime = Date.now();
    const duration = endTime - startTime;
    const fileStats = fs.statSync(outputPath);
    const fileSize = formatFileSize(fileStats.size);

    console.log('\n=== æ›´æ–°å®Œæˆ ===');
    console.log(`âœ… README å·²æ›´æ–°: ${outputPath}`);
    console.log(`ğŸ“ æ–‡ä»¶å¤§å°: ${fileSize}`);
    console.log(`â±ï¸  æ€»è€—æ—¶: ${duration}ms`);
    console.log(`ğŸ”„ æ›´æ–°ç±»å‹: ${hasExistingReadme ? 'å¢é‡æ›´æ–°ï¼ˆä¿ç•™ç”¨æˆ·å†…å®¹ï¼‰' : 'æ–°å»ºæ–‡æ¡£'}`);
    
    if (hasExistingReadme) {
      console.log(`ğŸ”’ ä¿ç•™ç”¨æˆ·ç« èŠ‚: ${userSections.size} ä¸ª`);
      console.log(`ğŸ“ ä¿ç•™ç”¨æˆ·å†…å®¹: ${preservedContent.length} è¡Œ`);
    }

    console.log('\nğŸ‰ README å¢é‡æ›´æ–°å®Œæˆ!');
    console.log('\nğŸ’¡ æç¤ºï¼š');
    console.log('  - è‡ªåŠ¨ç”Ÿæˆçš„ç« èŠ‚ï¼ˆé¡¹ç›®æ¦‚è§ˆã€ç›®å½•ç»“æ„ç­‰ï¼‰å·²æ›´æ–°');
    console.log('  - ç”¨æˆ·è‡ªå®šä¹‰çš„ç« èŠ‚å’Œå†…å®¹å·²å®Œæ•´ä¿ç•™');
    console.log('  - ä½¿ç”¨ --diff é€‰é¡¹å¯æŸ¥çœ‹è¯¦ç»†å˜æ›´ä¿¡æ¯');

  } catch (error) {
    console.error('âŒ README æ›´æ–°å¤±è´¥:', (error as Error).message);
    if (process.env.DEBUG || options.verbose) {
      console.error('è¯¦ç»†é”™è¯¯ä¿¡æ¯:', error);
    }
    process.exit(1);
  }
}

/**
 * æ‰§è¡Œ README ç”Ÿæˆé€»è¾‘çš„è¾…åŠ©å‡½æ•°
 * @param rootDir é¡¹ç›®æ ¹ç›®å½•
 * @param options å‘½ä»¤é€‰é¡¹
 */
async function executeGenerateReadme(rootDir: string, options: any): Promise<void> {
  const startTime = Date.now();

  try {
    console.log('=== AI å‹å¥½ README ç”Ÿæˆå™¨ ===');
    console.log(`é¡¹ç›®ç›®å½•: ${rootDir}`);
    console.log(`è¾“å‡ºæ–‡ä»¶: ${options.output}`);
    console.log(`æ–‡æ¡£æ¨¡æ¿: ${options.template}`);
    console.log(`æ–‡æ¡£è¯­è¨€: ${options.language}`);
    console.log(`é¢„è§ˆæ¨¡å¼: ${options.preview ? 'æ˜¯' : 'å¦'}`);
    console.log('==============================\n');

    // æ£€æŸ¥é¡¹ç›®ç›®å½•æ˜¯å¦å­˜åœ¨
    if (!fs.existsSync(rootDir)) {
      console.error(`âŒ é¡¹ç›®ç›®å½•ä¸å­˜åœ¨: ${rootDir}`);
      process.exit(1);
    }

    // æ™ºèƒ½å¤„ç†è¾“å‡ºè·¯å¾„
    let outputPath: string;
    
    if (!options.output || options.output.trim() === '') {
      // é»˜è®¤è¾“å‡ºåˆ°é¡¹ç›®æ ¹ç›®å½•ï¼Œç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„æ–‡ä»¶å
      const now = new Date();
      const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
      const filename = `readme-${timestamp}.md`;
      outputPath = path.join(rootDir, filename);
      console.log(`ğŸ“ ä½¿ç”¨é»˜è®¤è¾“å‡ºè·¯å¾„ï¼Œç”Ÿæˆæ–‡ä»¶å: ${filename}`);
    } else {
      outputPath = path.isAbsolute(options.output) 
        ? options.output 
        : path.join(rootDir, options.output);

      // æ£€æŸ¥æ˜¯å¦æ˜¯ç›®å½•æˆ–éœ€è¦ç”Ÿæˆæ—¶é—´æˆ³æ–‡ä»¶å
      if (fs.existsSync(outputPath) && fs.statSync(outputPath).isDirectory()) {
        // ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„æ–‡ä»¶å
        const now = new Date();
        const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
        const filename = `readme-${timestamp}.md`;
        outputPath = path.join(outputPath, filename);
        console.log(`ğŸ“ æ£€æµ‹åˆ°ç›®å½•è·¯å¾„ï¼Œè‡ªåŠ¨ç”Ÿæˆæ–‡ä»¶å: ${filename}`);
      } else if (!fs.existsSync(outputPath)) {
        // æ£€æŸ¥çˆ¶ç›®å½•æ˜¯å¦å­˜åœ¨ä¸”æ˜¯ç›®å½•
        const parentDir = path.dirname(outputPath);
        if (fs.existsSync(parentDir) && fs.statSync(parentDir).isDirectory()) {
          const basename = path.basename(options.output);
          if (!basename || basename === '.md' || basename === 'readme.md') {
            // ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„æ–‡ä»¶å
            const now = new Date();
            const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            const filename = `readme-${timestamp}.md`;
            outputPath = path.join(parentDir, filename);
            console.log(`ğŸ“ æ£€æµ‹åˆ°ç›®å½•è·¯å¾„ï¼Œè‡ªåŠ¨ç”Ÿæˆæ–‡ä»¶å: ${filename}`);
          }
        }
      }
    }

    // æ£€æŸ¥è¾“å‡ºæ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨ï¼ˆéé¢„è§ˆæ¨¡å¼ä¸”éå¼ºåˆ¶æ¨¡å¼ï¼‰
    if (!options.preview && !options.force && fs.existsSync(outputPath)) {
      console.error(`âŒ æ–‡ä»¶å·²å­˜åœ¨: ${outputPath}`);
      console.error('ğŸ’¡ ä½¿ç”¨ --force é€‰é¡¹å¼ºåˆ¶è¦†ç›–ï¼Œæˆ–ä½¿ç”¨ --preview é€‰é¡¹é¢„è§ˆ');
      process.exit(1);
    }

    if (options.verbose) {
      console.log('ğŸ” å¼€å§‹åˆ†æé¡¹ç›®ç»“æ„...');
    }

    // é¢„è§ˆæ¨¡å¼ï¼šç”Ÿæˆ README å†…å®¹åˆ°æ§åˆ¶å°
    if (options.preview) {
      console.log('ğŸ“ æ­£åœ¨ç”Ÿæˆ README é¢„è§ˆ...\n');
      
      const readmeContent = await generateReadme(
        rootDir,
        options.template,
        options.language,
        options.custom
      );

      console.log('=== README é¢„è§ˆ ===');
      console.log(readmeContent);
      console.log('\n=== é¢„è§ˆç»“æŸ ===');

      const endTime = Date.now();
      const duration = endTime - startTime;
      console.log(`\nâ±ï¸  ç”Ÿæˆè€—æ—¶: ${duration}ms`);
      console.log('ğŸ’¡ ä½¿ç”¨ --no-preview é€‰é¡¹æ¥å®é™…ä¿å­˜æ–‡ä»¶');
      
      return;
    }

    // æ­£å¼ç”Ÿæˆæ¨¡å¼ï¼šç”Ÿæˆå¹¶ä¿å­˜ README æ–‡ä»¶
    console.log('ğŸ“ æ­£åœ¨ç”Ÿæˆ README æ–‡æ¡£...');
    
    await generateReadmeToFile(
      rootDir,
      outputPath,
      options.template,
      options.language,
      options.custom
    );

    // æ˜¾ç¤ºç”Ÿæˆç»“æœç»Ÿè®¡
    const endTime = Date.now();
    const duration = endTime - startTime;
    const fileStats = fs.statSync(outputPath);
    const fileSize = formatFileSize(fileStats.size);

    console.log('\n=== ç”Ÿæˆå®Œæˆ ===');
    console.log(`âœ… README å·²ç”Ÿæˆ: ${outputPath}`);
    console.log(`ğŸ“ æ–‡ä»¶å¤§å°: ${fileSize}`);
    console.log(`â±ï¸  æ€»è€—æ—¶: ${duration}ms`);

    // å¦‚æœæ˜¯è¯¦ç»†æ¨¡å¼ï¼Œæ˜¾ç¤ºé¢å¤–çš„ç»Ÿè®¡ä¿¡æ¯
    if (options.verbose) {
      console.log('\n=== è¯¦ç»†ç»Ÿè®¡ ===');
      const content = fs.readFileSync(outputPath, 'utf8');
      const lines = content.split('\n').length;
      const words = content.split(/\s+/).length;
      const chars = content.length;
      
      console.log(`ğŸ“Š æ€»è¡Œæ•°: ${lines}`);
      console.log(`ğŸ“Š æ€»å­—æ•°: ${words}`);
      console.log(`ğŸ“Š æ€»å­—ç¬¦æ•°: ${chars}`);
    }

    console.log('\nğŸ‰ README ç”Ÿæˆå®Œæˆ!');

  } catch (error) {
    console.error('âŒ README ç”Ÿæˆå¤±è´¥:', (error as Error).message);
    if (process.env.DEBUG || options.verbose) {
      console.error('è¯¦ç»†é”™è¯¯ä¿¡æ¯:', error);
    }
    console.error('\nğŸ’¡ å¸¸è§é—®é¢˜è§£å†³æ–¹æ¡ˆ:');
    console.error('  1. æ£€æŸ¥é¡¹ç›®ç›®å½•æ˜¯å¦åŒ…å«æœ‰æ•ˆçš„ä»£ç æ–‡ä»¶');
    console.error('  2. ç¡®ä¿æœ‰ç½‘ç»œè¿æ¥ï¼ˆéœ€è¦è°ƒç”¨ AI æœåŠ¡ï¼‰');
    console.error('  3. æ£€æŸ¥è¾“å‡ºç›®å½•æ˜¯å¦æœ‰å†™å…¥æƒé™');
    console.error('  4. ä½¿ç”¨ --verbose é€‰é¡¹æŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯');
    process.exit(1);
  }
}

// ä¸»æå–å‘½ä»¤
program
  .command('extract')
  .description('æå–é¡¹ç›®ä¸­çš„ä»£ç å®ä½“')
  .argument('[rootDir]', 'é¡¹ç›®æ ¹ç›®å½•', process.cwd())
  .option('-o, --out <file>', 'è¾“å‡ºJSONæ–‡ä»¶è·¯å¾„', path.join(process.cwd(), 'data/entities.json'))
  .option('--stats', 'æ˜¾ç¤ºè¯¦ç»†ç»Ÿè®¡ä¿¡æ¯', false)
  .option('--pretty', 'ç¾åŒ–JSONè¾“å‡º', true)
  .option('--dry-run', 'é¢„è§ˆæ¨¡å¼ï¼Œä¸å†™å…¥æ–‡ä»¶', false)
  .action(async (rootDir, options) => {
    const startTime = Date.now();

    try {
      console.log('=== ä»£ç å®ä½“æå–å·¥å…· ===');
      console.log(`é¡¹ç›®ç›®å½•: ${rootDir}`);
      console.log(`è¾“å‡ºæ–‡ä»¶: ${options.out}`);
      console.log(`é¢„è§ˆæ¨¡å¼: ${options.dryRun ? 'æ˜¯' : 'å¦'}`);
      console.log('========================\n');

      // æ£€æŸ¥é¡¹ç›®ç›®å½•æ˜¯å¦å­˜åœ¨
      if (!fs.existsSync(rootDir)) {
        console.error(`âŒ é¡¹ç›®ç›®å½•ä¸å­˜åœ¨: ${rootDir}`);
        process.exit(1);
      }

      console.log('ğŸ” å¼€å§‹æ‰«æä»£ç æ–‡ä»¶...');

      // æå–å®ä½“
      const entities = await extractAllEntities(rootDir);

      console.log(`âœ… æ‰«æå®Œæˆï¼Œå…±å‘ç° ${entities.length} ä¸ªä»£ç å®ä½“\n`);

      // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
      if (options.stats) {
        displayExtractionStats(entities, startTime);
      }

      // å‡†å¤‡JSONè¾“å‡º
      const jsonOutput = options.pretty
        ? JSON.stringify(entities, null, 2)
        : JSON.stringify(entities);

      // å¦‚æœä¸æ˜¯é¢„è§ˆæ¨¡å¼ï¼Œåˆ™å†™å…¥æ–‡ä»¶
      if (!options.dryRun) {
        try {
          // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
          const outputDir = path.dirname(options.out);
          ensureDirectoryExists(outputDir);

          // å†™å…¥æ–‡ä»¶
          fs.writeFileSync(options.out, jsonOutput, 'utf8');

          // è·å–æ–‡ä»¶å¤§å°ä¿¡æ¯
          const fileStats = fs.statSync(options.out);
          const fileSize = formatFileSize(fileStats.size);

          console.log(`\nğŸ’¾ ç»“æœå·²ä¿å­˜åˆ°: ${options.out}`);
          console.log(`ğŸ“ æ–‡ä»¶å¤§å°: ${fileSize}`);

        } catch (writeError) {
          console.error('âŒ å†™å…¥æ–‡ä»¶å¤±è´¥:', writeError);
          process.exit(1);
        }
      } else {
        console.log('\nğŸ” é¢„è§ˆæ¨¡å¼ - ä»¥ä¸‹æ˜¯å‰3ä¸ªå®ä½“çš„ç¤ºä¾‹:');
        const sampleEntities = entities.slice(0, 3);
        console.log(JSON.stringify(sampleEntities, null, 2));
        console.log('\nğŸ’¡ ä½¿ç”¨ --no-dry-run é€‰é¡¹æ¥å®é™…ä¿å­˜æ–‡ä»¶');
      }

      console.log('\nğŸ‰ æå–ä»»åŠ¡å®Œæˆ!');

    } catch (error) {
      console.error('âŒ æå–å¤±è´¥:', (error as Error).message);
      if (process.env.DEBUG) {
        console.error('è¯¦ç»†é”™è¯¯ä¿¡æ¯:', error);
      }
      process.exit(1);
    }
  });

// éªŒè¯å‘½ä»¤ - éªŒè¯å·²æå–çš„å®ä½“æ–‡ä»¶
program
  .command('validate')
  .description('éªŒè¯å®ä½“JSONæ–‡ä»¶çš„æ ¼å¼å’Œå®Œæ•´æ€§')
  .argument('<file>', 'è¦éªŒè¯çš„JSONæ–‡ä»¶è·¯å¾„')
  .action(async (file) => {
    try {
      console.log('=== å®ä½“æ–‡ä»¶éªŒè¯å·¥å…· ===');
      console.log(`éªŒè¯æ–‡ä»¶: ${file}\n`);

      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      if (!fs.existsSync(file)) {
        console.error(`âŒ æ–‡ä»¶ä¸å­˜åœ¨: ${file}`);
        process.exit(1);
      }

      // è¯»å–å¹¶è§£ææ–‡ä»¶
      console.log('ğŸ“– è¯»å–æ–‡ä»¶...');
      const content = fs.readFileSync(file, 'utf8');

      console.log('ğŸ” è§£æJSON...');
      let entities;
      try {
        entities = JSON.parse(content);
      } catch (parseError) {
        console.error('âŒ JSONæ ¼å¼é”™è¯¯:', (parseError as Error).message);
        process.exit(1);
      }

      // éªŒè¯æ•°æ®ç»“æ„
      console.log('âœ… JSONæ ¼å¼æ­£ç¡®');

      if (!Array.isArray(entities)) {
        console.error('âŒ æ•°æ®ç»“æ„é”™è¯¯: æ ¹å¯¹è±¡åº”è¯¥æ˜¯æ•°ç»„');
        process.exit(1);
      }

      console.log(`âœ… æ•°æ®ç»“æ„æ­£ç¡®ï¼ŒåŒ…å« ${entities.length} ä¸ªå®ä½“`);

      // éªŒè¯å®ä½“æ ¼å¼
      let validEntities = 0;
      let issues = 0;

      const requiredFields = ['id', 'type', 'file', 'rawName'];

      entities.forEach((entity: any, index: number) => {
        let hasIssues = false;

        // æ£€æŸ¥å¿…éœ€å­—æ®µ
        requiredFields.forEach(field => {
          if (!entity[field]) {
            if (issues < 5) {  // åªæ˜¾ç¤ºå‰5ä¸ªé—®é¢˜
              console.log(`âš ï¸  å®ä½“ ${index}: ç¼ºå°‘å¿…éœ€å­—æ®µ '${field}'`);
            }
            hasIssues = true;
          }
        });

        // æ£€æŸ¥æ•°ç»„å­—æ®µ
        const arrayFields = ['IMPORTS', 'CALLS', 'EMITS', 'TEMPLATE_COMPONENTS', 'tags'];
        arrayFields.forEach(field => {
          if (entity[field] && !Array.isArray(entity[field])) {
            if (issues < 5) {
              console.log(`âš ï¸  å®ä½“ ${index}: å­—æ®µ '${field}' åº”è¯¥æ˜¯æ•°ç»„`);
            }
            hasIssues = true;
          }
        });

        if (hasIssues) {
          issues++;
        } else {
          validEntities++;
        }
      });

      if (issues > 5) {
        console.log(`âš ï¸  ... è¿˜æœ‰ ${issues - 5} ä¸ªç±»ä¼¼é—®é¢˜`);
      }

      console.log(`\n=== éªŒè¯ç»“æœ ===`);
      console.log(`âœ… æœ‰æ•ˆå®ä½“: ${validEntities}`);
      console.log(`âš ï¸  æœ‰é—®é¢˜å®ä½“: ${issues}`);
      console.log(`ğŸ“Š æœ‰æ•ˆç‡: ${((validEntities / entities.length) * 100).toFixed(1)}%`);

      if (issues === 0) {
        console.log('\nğŸ‰ æ‰€æœ‰å®ä½“éƒ½é€šè¿‡éªŒè¯!');
      } else {
        console.log('\nğŸ’¡ å»ºè®®æ£€æŸ¥å¹¶ä¿®å¤æœ‰é—®é¢˜çš„å®ä½“');
      }

    } catch (error) {
      console.error('âŒ éªŒè¯å¤±è´¥:', (error as Error).message);
      process.exit(1);
    }
  });

// æ–°å¢ï¼šç”Ÿæˆ README å‘½ä»¤
program
  .command('generate-readme')
  .description('ç”Ÿæˆ AI å‹å¥½çš„ README æ–‡æ¡£')
  .argument('[rootDir]', 'é¡¹ç›®æ ¹ç›®å½•', process.cwd())
  .option('-o, --output <file>', 'è¾“å‡º AI README æ–‡ä»¶è·¯å¾„ï¼ˆé»˜è®¤è¾“å‡ºåˆ°é¡¹ç›®æ ¹ç›®å½•ï¼‰', '')
  .option('-t, --template <type>', 'æ–‡æ¡£æ¨¡æ¿ç±»å‹', 'comprehensive')
  .option('-l, --language <lang>', 'æ–‡æ¡£è¯­è¨€', 'zh-CN')
  .option('-c, --custom <file>', 'è‡ªå®šä¹‰ markdown æ–‡ä»¶è·¯å¾„ï¼Œç”¨äºæ·»åŠ ç‰¹å®šä¸šåŠ¡è¦æ±‚', '')
  .option('--preview', 'é¢„è§ˆæ¨¡å¼ï¼Œè¾“å‡ºåˆ°æ§åˆ¶å°è€Œä¸ä¿å­˜æ–‡ä»¶', false)
  .option('--force', 'å¼ºåˆ¶è¦†ç›–å·²å­˜åœ¨çš„ README æ–‡ä»¶', false)
  .option('--verbose', 'æ˜¾ç¤ºè¯¦ç»†çš„ç”Ÿæˆè¿‡ç¨‹', false)
  .action(async (rootDir, options) => {
    // ç›´æ¥è°ƒç”¨ç”Ÿæˆå‡½æ•°ï¼Œå¤ç”¨é¡¹ç›®éå†å’Œåˆ†æèƒ½åŠ›
    await executeGenerateReadme(rootDir, options);
  });

// æ–°å¢ï¼šå¿«æ·å‘½ä»¤åˆ«å
program
  .command('readme')
  .description('ç”Ÿæˆ README æ–‡æ¡£çš„å¿«æ·å‘½ä»¤ï¼ˆgenerate-readme çš„åˆ«åï¼‰')
  .argument('[rootDir]', 'é¡¹ç›®æ ¹ç›®å½•', process.cwd())
  .option('-o, --output <file>', 'è¾“å‡º AI README æ–‡ä»¶è·¯å¾„ï¼ˆé»˜è®¤è¾“å‡ºåˆ°é¡¹ç›®æ ¹ç›®å½•ï¼‰', '')
  .option('-t, --template <type>', 'æ–‡æ¡£æ¨¡æ¿ç±»å‹', 'comprehensive')
  .option('-l, --language <lang>', 'æ–‡æ¡£è¯­è¨€', 'zh-CN')
  .option('-c, --custom <file>', 'è‡ªå®šä¹‰ markdown æ–‡ä»¶è·¯å¾„ï¼Œç”¨äºæ·»åŠ ç‰¹å®šä¸šåŠ¡è¦æ±‚', '')
  .option('--preview', 'é¢„è§ˆæ¨¡å¼ï¼Œè¾“å‡ºåˆ°æ§åˆ¶å°è€Œä¸ä¿å­˜æ–‡ä»¶', false)
  .option('--force', 'å¼ºåˆ¶è¦†ç›–å·²å­˜åœ¨çš„ README æ–‡ä»¶', false)
  .option('--verbose', 'æ˜¾ç¤ºè¯¦ç»†çš„ç”Ÿæˆè¿‡ç¨‹', false)
  .action(async (rootDir, options) => {
    // è°ƒç”¨ generate-readme å‘½ä»¤çš„ç›¸åŒé€»è¾‘
    console.log('ğŸ’¡ ä½¿ç”¨å¿«æ·å‘½ä»¤ "readme"ï¼Œç­‰åŒäº "generate-readme"\n');
    
    // å¤ç”¨ generate-readme çš„é€»è¾‘ï¼ˆç›´æ¥è°ƒç”¨ç”Ÿæˆå‡½æ•°ï¼‰
    await executeGenerateReadme(rootDir, options);
  });

// æ–°å¢ï¼šå¢é‡æ›´æ–° README å‘½ä»¤
program
  .command('patch-readme')
  .description('æ¸è¿›å¼æ›´æ–° AI å‹å¥½çš„ README æ–‡æ¡£')
  .argument('[rootDir]', 'é¡¹ç›®æ ¹ç›®å½•', process.cwd())
  .option('-o, --output <file>', 'è¾“å‡º AI README æ–‡ä»¶è·¯å¾„ï¼ˆé»˜è®¤è¾“å‡ºåˆ°é¡¹ç›®æ ¹ç›®å½•ï¼‰', '')
  .option('-l, --language <lang>', 'æ–‡æ¡£è¯­è¨€', 'zh-CN')
  .option('-c, --custom <file>', 'è‡ªå®šä¹‰ markdown æ–‡ä»¶è·¯å¾„ï¼Œç”¨äºæ·»åŠ ç‰¹å®šä¸šåŠ¡è¦æ±‚', '')
  .option('--preview', 'é¢„è§ˆæ¨¡å¼ï¼Œè¾“å‡ºåˆ°æ§åˆ¶å°è€Œä¸ä¿å­˜æ–‡ä»¶', false)
  .option('--force', 'å¼ºåˆ¶è¦†ç›–å·²å­˜åœ¨çš„ README æ–‡ä»¶', false)
  .option('--verbose', 'æ˜¾ç¤ºè¯¦ç»†çš„ç”Ÿæˆè¿‡ç¨‹', false)
  .option('--diff', 'æ˜¾ç¤ºä¸ç°æœ‰ README çš„å·®å¼‚', false)
  .action(async (rootDir, options) => {
    await executePatchReadme(rootDir, options);
  });

// æ–°å¢ï¼šå¸®åŠ©ä¿¡æ¯å‘½ä»¤
program
  .command('help-readme')
  .description('æ˜¾ç¤º README ç”Ÿæˆå™¨çš„è¯¦ç»†å¸®åŠ©ä¿¡æ¯')
  .action(() => {
    console.log('=== README ç”Ÿæˆå™¨å¸®åŠ© ===\n');
    
    console.log('ğŸ“ åŸºæœ¬ç”¨æ³•:');
    console.log('  parser-agent generate-readme [options] [é¡¹ç›®ç›®å½•]');
    console.log('  parser-agent readme [options] [é¡¹ç›®ç›®å½•]  # å¿«æ·å‘½ä»¤');
    console.log('  parser-agent patch-readme [options] [é¡¹ç›®ç›®å½•]  # æ¸è¿›å¼æ›´æ–°\n');
    
    console.log('ğŸ¯ å¸¸ç”¨ç¤ºä¾‹:');
    console.log('  # ç”Ÿæˆä¸­æ–‡ README åˆ°é¡¹ç›®æ ¹ç›®å½•ï¼ˆé»˜è®¤ï¼‰');
    console.log('  parser-agent readme');
    console.log('');
    console.log('  # æ¸è¿›å¼æ›´æ–°ç°æœ‰ README');
    console.log('  parser-agent patch-readme');
    console.log('');
    console.log('  # ç”Ÿæˆè‹±æ–‡ README åˆ°æŒ‡å®šè·¯å¾„');
    console.log('  parser-agent readme -l en-US -o ./docs/ai-readme.en.md');
    console.log('');
    console.log('  # è¾“å‡ºåˆ°ç›®å½•ï¼Œè‡ªåŠ¨ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„æ–‡ä»¶å');
    console.log('  parser-agent readme -o ./docs/');
    console.log('  parser-agent readme -o /path/to/output/directory/');
    console.log('');
    console.log('  # é¢„è§ˆ README å†…å®¹ï¼ˆä¸ä¿å­˜æ–‡ä»¶ï¼‰');
    console.log('  parser-agent readme --preview');
    console.log('');
    console.log('  # å¼ºåˆ¶è¦†ç›–ç°æœ‰æ–‡ä»¶ï¼Œæ˜¾ç¤ºè¯¦ç»†è¿‡ç¨‹');
    console.log('  parser-agent readme --force --verbose');
    console.log('');
    console.log('  # åˆ†ææŒ‡å®šé¡¹ç›®å¹¶ç”Ÿæˆ README');
    console.log('  parser-agent readme /path/to/project -o /path/to/output/ai-readme.md');
    console.log('');
    console.log('  # ä½¿ç”¨è‡ªå®šä¹‰ markdown æ–‡ä»¶æ·»åŠ ç‰¹å®šä¸šåŠ¡è¦æ±‚');
    console.log('  parser-agent readme -c ./custom.md');
    console.log('');
    console.log('  # ç»“åˆå¤šä¸ªé€‰é¡¹ä½¿ç”¨è‡ªå®šä¹‰æ–‡ä»¶');
    console.log('  parser-agent readme -c ./business-requirements.md -l en-US --preview');
    console.log('');
    
    console.log('âš™ï¸  é€‰é¡¹è¯´æ˜:');
    console.log('  -o, --output <path>     æŒ‡å®šè¾“å‡ºæ–‡ä»¶è·¯å¾„æˆ–ç›®å½•ï¼ˆé»˜è®¤: ai-readme.mdï¼‰');
    console.log('                          å¦‚æœæŒ‡å®šç›®å½•ï¼Œå°†è‡ªåŠ¨ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„æ–‡ä»¶å');
    console.log('  -t, --template <type>   æ–‡æ¡£æ¨¡æ¿ç±»å‹ï¼ˆé»˜è®¤: comprehensiveï¼‰');
    console.log('  -l, --language <lang>   æ–‡æ¡£è¯­è¨€ï¼ˆzh-CN: ä¸­æ–‡, en-US: è‹±æ–‡ï¼‰');
    console.log('  -c, --custom <file>     è‡ªå®šä¹‰ markdown æ–‡ä»¶è·¯å¾„ï¼Œç”¨äºæ·»åŠ ç‰¹å®šä¸šåŠ¡è¦æ±‚');
    console.log('  --preview               é¢„è§ˆæ¨¡å¼ï¼Œä¸ä¿å­˜æ–‡ä»¶');
    console.log('  --force                 å¼ºåˆ¶è¦†ç›–å·²å­˜åœ¨çš„æ–‡ä»¶');
    console.log('  --verbose               æ˜¾ç¤ºè¯¦ç»†çš„ç”Ÿæˆè¿‡ç¨‹');
    console.log('  --diff                  æ˜¾ç¤ºä¸ç°æœ‰ README çš„å·®å¼‚ï¼ˆpatch-readme ä¸“ç”¨ï¼‰');
    console.log('');
    
    console.log('ğŸ”§ æ¨¡æ¿ç±»å‹:');
    console.log('  comprehensive    å®Œæ•´è¯¦ç»†çš„ READMEï¼ˆé»˜è®¤ï¼‰');
    console.log('  simple           ç®€æ´ç‰ˆæœ¬çš„ README');
    console.log('  technical        æŠ€æœ¯å¯¼å‘çš„ README');
    console.log('');
    
    console.log('ğŸŒ æ”¯æŒè¯­è¨€:');
    console.log('  zh-CN           ä¸­æ–‡ï¼ˆé»˜è®¤ï¼‰');
    console.log('  en-US           è‹±æ–‡');
    console.log('');
    
    console.log('ğŸ’¡ ä½¿ç”¨æç¤º:');
    console.log('  â€¢ ç”Ÿæˆå™¨ä¼šè‡ªåŠ¨åˆ†æé¡¹ç›®ç»“æ„ã€ä¾èµ–å…³ç³»å’Œä»£ç ç‰¹å¾');
    console.log('  â€¢ é¦–æ¬¡è¿è¡Œå¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—´ï¼Œè¯·è€å¿ƒç­‰å¾…');
    console.log('  â€¢ å»ºè®®åœ¨é¡¹ç›®æ ¹ç›®å½•è¿è¡Œä»¥è·å¾—æœ€ä½³åˆ†ææ•ˆæœ');
    console.log('  â€¢ ä½¿ç”¨ --preview é€‰é¡¹å¯ä»¥å…ˆæŸ¥çœ‹æ•ˆæœå†å†³å®šæ˜¯å¦ä¿å­˜');
    console.log('  â€¢ patch-readme å‘½ä»¤æ”¯æŒæ¸è¿›å¼æ›´æ–°ï¼Œä¿æŒç°æœ‰å†…å®¹çš„è¿ç»­æ€§');
    console.log('  â€¢ ä½¿ç”¨ --custom é€‰é¡¹å¯ä»¥æ·»åŠ ç‰¹å®šçš„ä¸šåŠ¡è¦æ±‚å’Œä¼˜åŒ–æŒ‡å¯¼');
    console.log('  â€¢ è‡ªå®šä¹‰æ–‡ä»¶ä¸­çš„å†…å®¹ä¼šè¢«é‡ç‚¹å…³æ³¨å¹¶èå…¥æœ€ç»ˆçš„ README ä¸­');
    console.log('  â€¢ ç½‘ç»œè¿æ¥æ˜¯å¿…éœ€çš„ï¼Œå› ä¸ºéœ€è¦è°ƒç”¨ AI æœåŠ¡');
    console.log('  â€¢ è¾“å‡ºè·¯å¾„æ”¯æŒç›®å½•ï¼Œä¼šè‡ªåŠ¨ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„æ–‡ä»¶åï¼ˆå¦‚ï¼šreadme-20241201143022.mdï¼‰');
    console.log('');
    
    console.log('ğŸ› æ•…éšœæ’é™¤:');
    console.log('  â€¢ å¦‚æœç”Ÿæˆå¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
    console.log('  â€¢ ç¡®ä¿é¡¹ç›®ç›®å½•åŒ…å«æœ‰æ•ˆçš„ä»£ç æ–‡ä»¶');
    console.log('  â€¢ ä½¿ç”¨ --verbose é€‰é¡¹æŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯');
    console.log('  â€¢ æ£€æŸ¥è¾“å‡ºç›®å½•çš„å†™å…¥æƒé™');
    console.log('');
    
    console.log('ğŸ“ éœ€è¦å¸®åŠ©?');
    console.log('  ä½¿ç”¨ "parser-agent --help" æŸ¥çœ‹æ‰€æœ‰å¯ç”¨å‘½ä»¤');
  });

// é»˜è®¤å‘½ä»¤ï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
program
  .argument('[rootDir]', 'é¡¹ç›®æ ¹ç›®å½•', process.cwd())
  .option('-o, --out <file>', 'è¾“å‡ºJSONæ–‡ä»¶è·¯å¾„', path.join(process.cwd(), 'data/entities.json'))
  .action(async (rootDir, options) => {
    // å¦‚æœæ²¡æœ‰æŒ‡å®šå­å‘½ä»¤ï¼Œåˆ™æ‰§è¡Œé»˜è®¤çš„æå–è¡Œä¸º
    if (!process.argv.slice(2).some(arg => ['extract', 'validate'].includes(arg))) {
      console.log('ğŸ’¡ ä½¿ç”¨é»˜è®¤æå–æ¨¡å¼ï¼Œå»ºè®®ä½¿ç”¨ "extract" å­å‘½ä»¤ä»¥è·å¾—æ›´å¤šé€‰é¡¹\n');

      try {
        const entities = await extractAllEntities(rootDir);

        // è¾“å‡ºåˆ°æ§åˆ¶å°ï¼ˆä¿æŒåŸæœ‰è¡Œä¸ºï¼‰
        console.log(JSON.stringify(entities, null, 2));

        // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
        const outputDir = path.dirname(options.out);
        ensureDirectoryExists(outputDir);

        // ä¿å­˜åˆ°æ–‡ä»¶
        fs.writeFileSync(options.out, JSON.stringify(entities, null, 2));
        console.log(`\nâœ… å·²ä¿å­˜åˆ°: ${options.out}`);

      } catch (error) {
        console.error('âŒ æå–å¤±è´¥:', error);
        process.exit(1);
      }
    }
  });

// è§£æå‘½ä»¤è¡Œå‚æ•°
program.parse(process.argv); 