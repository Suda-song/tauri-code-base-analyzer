#!/usr/bin/env node

import { Command } from 'commander';
import { extractAllEntities } from './fileWalker';
import { generateReadmeToFile, generateReadme } from './readme-generator';
import fs from 'fs';
import path from 'path';

// 创建命令行程序
const program = new Command();

program
  .name('parser-agent')
  .description('从 Vue/TS/TSX 项目中提取代码实体信息')
  .version('1.0.0');

/**
 * 确保目录存在，如果不存在则创建
 * @param dirPath 目录路径
 */
function ensureDirectoryExists(dirPath: string): void {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
    console.log(`已创建输出目录: ${dirPath}`);
  }
}

/**
 * 格式化文件大小显示
 * @param bytes 字节数
 * @returns 格式化后的文件大小字符串
 */
function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes';

  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * 显示提取结果的统计信息
 * @param entities 提取的实体数组
 * @param startTime 开始时间
 */
function displayExtractionStats(entities: any[], startTime: number): void {
  const endTime = Date.now();
  const duration = endTime - startTime;

  console.log('\n=== 提取统计信息 ===');
  console.log(`总实体数: ${entities.length}`);
  console.log(`提取耗时: ${duration}ms`);

  // 按类型统计实体
  const typeStats: {[key: string]: number} = {};
  entities.forEach(entity => {
    typeStats[entity.type] = (typeStats[entity.type] || 0) + 1;
  });

  console.log('\n实体类型分布:');
  Object.entries(typeStats)
    .sort((a, b) => b[1] - a[1])  // 按数量降序排列
    .forEach(([type, count]) => {
      const percentage = ((count / entities.length) * 100).toFixed(1);
      console.log(`  ${type}: ${count} (${percentage}%)`);
    });

  // 按文件类型统计
  const fileStats: {[key: string]: number} = {};
  entities.forEach(entity => {
    const ext = path.extname(entity.file).toLowerCase() || 'no-ext';
    fileStats[ext] = (fileStats[ext] || 0) + 1;
  });

  console.log('\n文件类型分布:');
  Object.entries(fileStats)
    .sort((a, b) => b[1] - a[1])
    .forEach(([ext, count]) => {
      console.log(`  ${ext}: ${count} 个文件`);
    });
}

/**
 * 解析README内容，识别自动生成的部分和用户编辑的部分
 */
function parseReadmeStructure(content: string): {
  userSections: Map<string, string>;
  autoSections: Set<string>;
  preservedContent: string[];
} {
  const lines = content.split('\n');
  const userSections = new Map<string, string>();
  const autoSections = new Set([
    '📊 Project Overview',
    '🗂️ Project Directory Structure', 
    '📂 Detailed Directory Analysis',
    '📈 Project Statistics',
    '## 📊 项目概览',
    '## 🗂️ 项目目录结构',
    '## 📂 详细目录分析',
    '## 📈 项目统计'
  ]);
  
  let currentSection = '';
  let currentContent: string[] = [];
  let inAutoGeneratedSection = false;
  const preservedContent: string[] = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // 检测是否是标题行
    if (line.startsWith('##') || line.startsWith('#')) {
      // 保存上一个section
      if (currentSection && !inAutoGeneratedSection) {
        userSections.set(currentSection, currentContent.join('\n'));
      } else if (!inAutoGeneratedSection) {
        preservedContent.push(...currentContent);
      }
      
      currentSection = line.trim();
      currentContent = [line];
      inAutoGeneratedSection = autoSections.has(currentSection.replace(/^#+\s*/, ''));
    } else {
      currentContent.push(line);
    }
  }
  
  // 处理最后一个section
  if (currentSection && !inAutoGeneratedSection) {
    userSections.set(currentSection, currentContent.join('\n'));
  } else if (!inAutoGeneratedSection) {
    preservedContent.push(...currentContent);
  }

  return { userSections, autoSections, preservedContent };
}

/**
 * 合并新内容和现有用户内容
 */
function mergeReadmeContent(
  newContent: string, 
  userSections: Map<string, string>,
  preservedContent: string[]
): string {
  const newLines = newContent.split('\n');
  const result: string[] = [];
  
  let currentSection = '';
  let skipCurrentSection = false;
  
  for (let i = 0; i < newLines.length; i++) {
    const line = newLines[i];
    
    if (line.startsWith('##') || line.startsWith('#')) {
      // 结束上一个section的跳过状态
      skipCurrentSection = false;
      currentSection = line.trim();
      
      // 检查是否有用户自定义版本的这个section
      const sectionKey = currentSection.replace(/^#+\s*/, '');
      if (userSections.has(currentSection)) {
        // 使用用户自定义内容
        result.push(userSections.get(currentSection)!);
        skipCurrentSection = true;
        continue;
      }
    }
    
    if (!skipCurrentSection) {
      result.push(line);
    }
  }
  
  // 添加用户保留的内容
  if (preservedContent.length > 0) {
    result.push('', '---', '', '## 📝 User Preserved Content', '');
    result.push(...preservedContent);
  }
  
  return result.join('\n');
}

/**
 * 执行真正的增量 README 更新逻辑的辅助函数
 * @param rootDir 项目根目录
 * @param options 命令选项
 */
async function executePatchReadme(rootDir: string, options: any): Promise<void> {
  const startTime = Date.now();

  try {
    console.log('=== AI README 增量更新器 ===');
    console.log(`项目目录: ${rootDir}`);
    console.log(`输出文件: ${options.output}`);
    console.log(`文档语言: ${options.language}`);
    console.log(`预览模式: ${options.preview ? '是' : '否'}`);
    console.log(`差异模式: ${options.diff ? '是' : '否'}`);
    console.log('=====================================\n');

    // 检查项目目录是否存在
    if (!fs.existsSync(rootDir)) {
      console.error(`❌ 项目目录不存在: ${rootDir}`);
      process.exit(1);
    }

    // 智能处理输出路径
    let outputPath: string;
    
    if (!options.output || options.output.trim() === '') {
      // 默认输出到项目根目录，生成带时间戳的文件名
      const now = new Date();
      const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
      const filename = `readme-${timestamp}.md`;
      outputPath = path.join(rootDir, filename);
      console.log(`📝 使用默认输出路径，生成文件名: ${filename}`);
    } else {
      outputPath = path.isAbsolute(options.output) 
        ? options.output 
        : path.join(rootDir, options.output);

      // 检查是否是目录或需要生成时间戳文件名
      if (fs.existsSync(outputPath) && fs.statSync(outputPath).isDirectory()) {
        // 生成带时间戳的文件名
        const now = new Date();
        const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
        const filename = `readme-${timestamp}.md`;
        outputPath = path.join(outputPath, filename);
        console.log(`📝 检测到目录路径，自动生成文件名: ${filename}`);
      } else if (!fs.existsSync(outputPath)) {
        // 检查父目录是否存在且是目录
        const parentDir = path.dirname(outputPath);
        if (fs.existsSync(parentDir) && fs.statSync(parentDir).isDirectory()) {
          const basename = path.basename(options.output);
          if (!basename || basename === '.md' || basename === 'readme.md') {
            // 生成带时间戳的文件名
            const now = new Date();
            const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            const filename = `readme-${timestamp}.md`;
            outputPath = path.join(parentDir, filename);
            console.log(`📝 检测到目录路径，自动生成文件名: ${filename}`);
          }
        }
      }
    }

    // 检查现有 README 文件
    let existingContent = '';
    let hasExistingReadme = false;
    let userSections = new Map<string, string>();
    let preservedContent: string[] = [];
    
    if (fs.existsSync(outputPath)) {
      existingContent = fs.readFileSync(outputPath, 'utf8');
      hasExistingReadme = true;
      console.log(`📄 检测到现有 README 文件: ${outputPath}`);
      
      // 解析现有README结构
      const parsed = parseReadmeStructure(existingContent);
      userSections = parsed.userSections;
      preservedContent = parsed.preservedContent;
      
      console.log(`📋 解析到 ${userSections.size} 个用户自定义章节`);
      console.log(`📝 保留 ${preservedContent.length} 行用户内容`);
    } else {
      console.log(`📄 将创建新的 README 文件: ${outputPath}`);
    }

    if (options.verbose) {
      console.log('🔍 开始分析项目结构变更...');
    }

    // 生成新的 README 内容
    console.log('📝 正在生成更新的 README 文档...');
    
    const newContent = await generateReadme(
      rootDir,
      'engineering-focused', // 使用工程聚焦的模板
      options.language,
      options.custom
    );

    // 如果有现有README，进行智能合并
    let finalContent = newContent;
    if (hasExistingReadme && userSections.size > 0) {
      console.log('🔄 正在进行智能内容合并...');
      finalContent = mergeReadmeContent(newContent, userSections, preservedContent);
      console.log('✅ 用户自定义内容已保留');
    }

    // 如果是差异模式，显示差异
    if (options.diff && hasExistingReadme) {
      console.log('\n=== 文档变更差异 ===');
      const oldLines = existingContent.split('\n').length;
      const newLines = finalContent.split('\n').length;
      const sizeDiff = finalContent.length - existingContent.length;
      
      console.log(`📊 行数变化: ${oldLines} → ${newLines} (${newLines - oldLines >= 0 ? '+' : ''}${newLines - oldLines})`);
      console.log(`📏 大小变化: ${formatFileSize(existingContent.length)} → ${formatFileSize(finalContent.length)} (${sizeDiff >= 0 ? '+' : ''}${formatFileSize(Math.abs(sizeDiff))})`);
      console.log(`🔒 保留用户章节: ${userSections.size} 个`);
      console.log(`📝 保留用户内容: ${preservedContent.length} 行`);
    }

    // 预览模式
    if (options.preview) {
      console.log('\n=== README 增量更新预览 ===');
      if (hasExistingReadme) {
        console.log('🔄 增量更新模式：将保留用户自定义内容，仅更新自动生成部分');
        console.log('\n📋 将保留的用户章节：');
        userSections.forEach((content, section) => {
          console.log(`  - ${section}`);
        });
      } else {
        console.log('📄 新建模式：将创建全新的README文件');
      }
      
      console.log('\n📝 预览内容（前50行）：');
      console.log(finalContent.split('\n').slice(0, 50).join('\n'));
      console.log('\n... (内容截断) ...');
      console.log('\n=== 预览结束 ===');

      const endTime = Date.now();
      const duration = endTime - startTime;
      console.log(`\n⏱️  生成耗时: ${duration}ms`);
      console.log('💡 使用 --no-preview 选项来实际保存更新');
      
      return;
    }

    // 保存更新的 README
    fs.writeFileSync(outputPath, finalContent, 'utf8');

    // 显示更新结果
    const endTime = Date.now();
    const duration = endTime - startTime;
    const fileStats = fs.statSync(outputPath);
    const fileSize = formatFileSize(fileStats.size);

    console.log('\n=== 更新完成 ===');
    console.log(`✅ README 已更新: ${outputPath}`);
    console.log(`📁 文件大小: ${fileSize}`);
    console.log(`⏱️  总耗时: ${duration}ms`);
    console.log(`🔄 更新类型: ${hasExistingReadme ? '增量更新（保留用户内容）' : '新建文档'}`);
    
    if (hasExistingReadme) {
      console.log(`🔒 保留用户章节: ${userSections.size} 个`);
      console.log(`📝 保留用户内容: ${preservedContent.length} 行`);
    }

    console.log('\n🎉 README 增量更新完成!');
    console.log('\n💡 提示：');
    console.log('  - 自动生成的章节（项目概览、目录结构等）已更新');
    console.log('  - 用户自定义的章节和内容已完整保留');
    console.log('  - 使用 --diff 选项可查看详细变更信息');

  } catch (error) {
    console.error('❌ README 更新失败:', (error as Error).message);
    if (process.env.DEBUG || options.verbose) {
      console.error('详细错误信息:', error);
    }
    process.exit(1);
  }
}

/**
 * 执行 README 生成逻辑的辅助函数
 * @param rootDir 项目根目录
 * @param options 命令选项
 */
async function executeGenerateReadme(rootDir: string, options: any): Promise<void> {
  const startTime = Date.now();

  try {
    console.log('=== AI 友好 README 生成器 ===');
    console.log(`项目目录: ${rootDir}`);
    console.log(`输出文件: ${options.output}`);
    console.log(`文档模板: ${options.template}`);
    console.log(`文档语言: ${options.language}`);
    console.log(`预览模式: ${options.preview ? '是' : '否'}`);
    console.log('==============================\n');

    // 检查项目目录是否存在
    if (!fs.existsSync(rootDir)) {
      console.error(`❌ 项目目录不存在: ${rootDir}`);
      process.exit(1);
    }

    // 智能处理输出路径
    let outputPath: string;
    
    if (!options.output || options.output.trim() === '') {
      // 默认输出到项目根目录，生成带时间戳的文件名
      const now = new Date();
      const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
      const filename = `readme-${timestamp}.md`;
      outputPath = path.join(rootDir, filename);
      console.log(`📝 使用默认输出路径，生成文件名: ${filename}`);
    } else {
      outputPath = path.isAbsolute(options.output) 
        ? options.output 
        : path.join(rootDir, options.output);

      // 检查是否是目录或需要生成时间戳文件名
      if (fs.existsSync(outputPath) && fs.statSync(outputPath).isDirectory()) {
        // 生成带时间戳的文件名
        const now = new Date();
        const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
        const filename = `readme-${timestamp}.md`;
        outputPath = path.join(outputPath, filename);
        console.log(`📝 检测到目录路径，自动生成文件名: ${filename}`);
      } else if (!fs.existsSync(outputPath)) {
        // 检查父目录是否存在且是目录
        const parentDir = path.dirname(outputPath);
        if (fs.existsSync(parentDir) && fs.statSync(parentDir).isDirectory()) {
          const basename = path.basename(options.output);
          if (!basename || basename === '.md' || basename === 'readme.md') {
            // 生成带时间戳的文件名
            const now = new Date();
            const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
            const filename = `readme-${timestamp}.md`;
            outputPath = path.join(parentDir, filename);
            console.log(`📝 检测到目录路径，自动生成文件名: ${filename}`);
          }
        }
      }
    }

    // 检查输出文件是否已存在（非预览模式且非强制模式）
    if (!options.preview && !options.force && fs.existsSync(outputPath)) {
      console.error(`❌ 文件已存在: ${outputPath}`);
      console.error('💡 使用 --force 选项强制覆盖，或使用 --preview 选项预览');
      process.exit(1);
    }

    if (options.verbose) {
      console.log('🔍 开始分析项目结构...');
    }

    // 预览模式：生成 README 内容到控制台
    if (options.preview) {
      console.log('📝 正在生成 README 预览...\n');
      
      const readmeContent = await generateReadme(
        rootDir,
        options.template,
        options.language,
        options.custom
      );

      console.log('=== README 预览 ===');
      console.log(readmeContent);
      console.log('\n=== 预览结束 ===');

      const endTime = Date.now();
      const duration = endTime - startTime;
      console.log(`\n⏱️  生成耗时: ${duration}ms`);
      console.log('💡 使用 --no-preview 选项来实际保存文件');
      
      return;
    }

    // 正式生成模式：生成并保存 README 文件
    console.log('📝 正在生成 README 文档...');
    
    await generateReadmeToFile(
      rootDir,
      outputPath,
      options.template,
      options.language,
      options.custom
    );

    // 显示生成结果统计
    const endTime = Date.now();
    const duration = endTime - startTime;
    const fileStats = fs.statSync(outputPath);
    const fileSize = formatFileSize(fileStats.size);

    console.log('\n=== 生成完成 ===');
    console.log(`✅ README 已生成: ${outputPath}`);
    console.log(`📁 文件大小: ${fileSize}`);
    console.log(`⏱️  总耗时: ${duration}ms`);

    // 如果是详细模式，显示额外的统计信息
    if (options.verbose) {
      console.log('\n=== 详细统计 ===');
      const content = fs.readFileSync(outputPath, 'utf8');
      const lines = content.split('\n').length;
      const words = content.split(/\s+/).length;
      const chars = content.length;
      
      console.log(`📊 总行数: ${lines}`);
      console.log(`📊 总字数: ${words}`);
      console.log(`📊 总字符数: ${chars}`);
    }

    console.log('\n🎉 README 生成完成!');

  } catch (error) {
    console.error('❌ README 生成失败:', (error as Error).message);
    if (process.env.DEBUG || options.verbose) {
      console.error('详细错误信息:', error);
    }
    console.error('\n💡 常见问题解决方案:');
    console.error('  1. 检查项目目录是否包含有效的代码文件');
    console.error('  2. 确保有网络连接（需要调用 AI 服务）');
    console.error('  3. 检查输出目录是否有写入权限');
    console.error('  4. 使用 --verbose 选项查看详细错误信息');
    process.exit(1);
  }
}

// 主提取命令
program
  .command('extract')
  .description('提取项目中的代码实体')
  .argument('[rootDir]', '项目根目录', process.cwd())
  .option('-o, --out <file>', '输出JSON文件路径', path.join(process.cwd(), 'data/entities.json'))
  .option('--stats', '显示详细统计信息', false)
  .option('--pretty', '美化JSON输出', true)
  .option('--dry-run', '预览模式，不写入文件', false)
  .action(async (rootDir, options) => {
    const startTime = Date.now();

    try {
      console.log('=== 代码实体提取工具 ===');
      console.log(`项目目录: ${rootDir}`);
      console.log(`输出文件: ${options.out}`);
      console.log(`预览模式: ${options.dryRun ? '是' : '否'}`);
      console.log('========================\n');

      // 检查项目目录是否存在
      if (!fs.existsSync(rootDir)) {
        console.error(`❌ 项目目录不存在: ${rootDir}`);
        process.exit(1);
      }

      console.log('🔍 开始扫描代码文件...');

      // 提取实体
      const entities = await extractAllEntities(rootDir);

      console.log(`✅ 扫描完成，共发现 ${entities.length} 个代码实体\n`);

      // 显示统计信息
      if (options.stats) {
        displayExtractionStats(entities, startTime);
      }

      // 准备JSON输出
      const jsonOutput = options.pretty
        ? JSON.stringify(entities, null, 2)
        : JSON.stringify(entities);

      // 如果不是预览模式，则写入文件
      if (!options.dryRun) {
        try {
          // 确保输出目录存在
          const outputDir = path.dirname(options.out);
          ensureDirectoryExists(outputDir);

          // 写入文件
          fs.writeFileSync(options.out, jsonOutput, 'utf8');

          // 获取文件大小信息
          const fileStats = fs.statSync(options.out);
          const fileSize = formatFileSize(fileStats.size);

          console.log(`\n💾 结果已保存到: ${options.out}`);
          console.log(`📁 文件大小: ${fileSize}`);

        } catch (writeError) {
          console.error('❌ 写入文件失败:', writeError);
          process.exit(1);
        }
      } else {
        console.log('\n🔍 预览模式 - 以下是前3个实体的示例:');
        const sampleEntities = entities.slice(0, 3);
        console.log(JSON.stringify(sampleEntities, null, 2));
        console.log('\n💡 使用 --no-dry-run 选项来实际保存文件');
      }

      console.log('\n🎉 提取任务完成!');

    } catch (error) {
      console.error('❌ 提取失败:', (error as Error).message);
      if (process.env.DEBUG) {
        console.error('详细错误信息:', error);
      }
      process.exit(1);
    }
  });

// 验证命令 - 验证已提取的实体文件
program
  .command('validate')
  .description('验证实体JSON文件的格式和完整性')
  .argument('<file>', '要验证的JSON文件路径')
  .action(async (file) => {
    try {
      console.log('=== 实体文件验证工具 ===');
      console.log(`验证文件: ${file}\n`);

      // 检查文件是否存在
      if (!fs.existsSync(file)) {
        console.error(`❌ 文件不存在: ${file}`);
        process.exit(1);
      }

      // 读取并解析文件
      console.log('📖 读取文件...');
      const content = fs.readFileSync(file, 'utf8');

      console.log('🔍 解析JSON...');
      let entities;
      try {
        entities = JSON.parse(content);
      } catch (parseError) {
        console.error('❌ JSON格式错误:', (parseError as Error).message);
        process.exit(1);
      }

      // 验证数据结构
      console.log('✅ JSON格式正确');

      if (!Array.isArray(entities)) {
        console.error('❌ 数据结构错误: 根对象应该是数组');
        process.exit(1);
      }

      console.log(`✅ 数据结构正确，包含 ${entities.length} 个实体`);

      // 验证实体格式
      let validEntities = 0;
      let issues = 0;

      const requiredFields = ['id', 'type', 'file', 'rawName'];

      entities.forEach((entity: any, index: number) => {
        let hasIssues = false;

        // 检查必需字段
        requiredFields.forEach(field => {
          if (!entity[field]) {
            if (issues < 5) {  // 只显示前5个问题
              console.log(`⚠️  实体 ${index}: 缺少必需字段 '${field}'`);
            }
            hasIssues = true;
          }
        });

        // 检查数组字段
        const arrayFields = ['IMPORTS', 'CALLS', 'EMITS', 'TEMPLATE_COMPONENTS', 'tags'];
        arrayFields.forEach(field => {
          if (entity[field] && !Array.isArray(entity[field])) {
            if (issues < 5) {
              console.log(`⚠️  实体 ${index}: 字段 '${field}' 应该是数组`);
            }
            hasIssues = true;
          }
        });

        if (hasIssues) {
          issues++;
        } else {
          validEntities++;
        }
      });

      if (issues > 5) {
        console.log(`⚠️  ... 还有 ${issues - 5} 个类似问题`);
      }

      console.log(`\n=== 验证结果 ===`);
      console.log(`✅ 有效实体: ${validEntities}`);
      console.log(`⚠️  有问题实体: ${issues}`);
      console.log(`📊 有效率: ${((validEntities / entities.length) * 100).toFixed(1)}%`);

      if (issues === 0) {
        console.log('\n🎉 所有实体都通过验证!');
      } else {
        console.log('\n💡 建议检查并修复有问题的实体');
      }

    } catch (error) {
      console.error('❌ 验证失败:', (error as Error).message);
      process.exit(1);
    }
  });

// 新增：生成 README 命令
program
  .command('generate-readme')
  .description('生成 AI 友好的 README 文档')
  .argument('[rootDir]', '项目根目录', process.cwd())
  .option('-o, --output <file>', '输出 AI README 文件路径（默认输出到项目根目录）', '')
  .option('-t, --template <type>', '文档模板类型', 'comprehensive')
  .option('-l, --language <lang>', '文档语言', 'zh-CN')
  .option('-c, --custom <file>', '自定义 markdown 文件路径，用于添加特定业务要求', '')
  .option('--preview', '预览模式，输出到控制台而不保存文件', false)
  .option('--force', '强制覆盖已存在的 README 文件', false)
  .option('--verbose', '显示详细的生成过程', false)
  .action(async (rootDir, options) => {
    // 直接调用生成函数，复用项目遍历和分析能力
    await executeGenerateReadme(rootDir, options);
  });

// 新增：快捷命令别名
program
  .command('readme')
  .description('生成 README 文档的快捷命令（generate-readme 的别名）')
  .argument('[rootDir]', '项目根目录', process.cwd())
  .option('-o, --output <file>', '输出 AI README 文件路径（默认输出到项目根目录）', '')
  .option('-t, --template <type>', '文档模板类型', 'comprehensive')
  .option('-l, --language <lang>', '文档语言', 'zh-CN')
  .option('-c, --custom <file>', '自定义 markdown 文件路径，用于添加特定业务要求', '')
  .option('--preview', '预览模式，输出到控制台而不保存文件', false)
  .option('--force', '强制覆盖已存在的 README 文件', false)
  .option('--verbose', '显示详细的生成过程', false)
  .action(async (rootDir, options) => {
    // 调用 generate-readme 命令的相同逻辑
    console.log('💡 使用快捷命令 "readme"，等同于 "generate-readme"\n');
    
    // 复用 generate-readme 的逻辑（直接调用生成函数）
    await executeGenerateReadme(rootDir, options);
  });

// 新增：增量更新 README 命令
program
  .command('patch-readme')
  .description('渐进式更新 AI 友好的 README 文档')
  .argument('[rootDir]', '项目根目录', process.cwd())
  .option('-o, --output <file>', '输出 AI README 文件路径（默认输出到项目根目录）', '')
  .option('-l, --language <lang>', '文档语言', 'zh-CN')
  .option('-c, --custom <file>', '自定义 markdown 文件路径，用于添加特定业务要求', '')
  .option('--preview', '预览模式，输出到控制台而不保存文件', false)
  .option('--force', '强制覆盖已存在的 README 文件', false)
  .option('--verbose', '显示详细的生成过程', false)
  .option('--diff', '显示与现有 README 的差异', false)
  .action(async (rootDir, options) => {
    await executePatchReadme(rootDir, options);
  });

// 新增：帮助信息命令
program
  .command('help-readme')
  .description('显示 README 生成器的详细帮助信息')
  .action(() => {
    console.log('=== README 生成器帮助 ===\n');
    
    console.log('📝 基本用法:');
    console.log('  parser-agent generate-readme [options] [项目目录]');
    console.log('  parser-agent readme [options] [项目目录]  # 快捷命令');
    console.log('  parser-agent patch-readme [options] [项目目录]  # 渐进式更新\n');
    
    console.log('🎯 常用示例:');
    console.log('  # 生成中文 README 到项目根目录（默认）');
    console.log('  parser-agent readme');
    console.log('');
    console.log('  # 渐进式更新现有 README');
    console.log('  parser-agent patch-readme');
    console.log('');
    console.log('  # 生成英文 README 到指定路径');
    console.log('  parser-agent readme -l en-US -o ./docs/ai-readme.en.md');
    console.log('');
    console.log('  # 输出到目录，自动生成带时间戳的文件名');
    console.log('  parser-agent readme -o ./docs/');
    console.log('  parser-agent readme -o /path/to/output/directory/');
    console.log('');
    console.log('  # 预览 README 内容（不保存文件）');
    console.log('  parser-agent readme --preview');
    console.log('');
    console.log('  # 强制覆盖现有文件，显示详细过程');
    console.log('  parser-agent readme --force --verbose');
    console.log('');
    console.log('  # 分析指定项目并生成 README');
    console.log('  parser-agent readme /path/to/project -o /path/to/output/ai-readme.md');
    console.log('');
    console.log('  # 使用自定义 markdown 文件添加特定业务要求');
    console.log('  parser-agent readme -c ./custom.md');
    console.log('');
    console.log('  # 结合多个选项使用自定义文件');
    console.log('  parser-agent readme -c ./business-requirements.md -l en-US --preview');
    console.log('');
    
    console.log('⚙️  选项说明:');
    console.log('  -o, --output <path>     指定输出文件路径或目录（默认: ai-readme.md）');
    console.log('                          如果指定目录，将自动生成带时间戳的文件名');
    console.log('  -t, --template <type>   文档模板类型（默认: comprehensive）');
    console.log('  -l, --language <lang>   文档语言（zh-CN: 中文, en-US: 英文）');
    console.log('  -c, --custom <file>     自定义 markdown 文件路径，用于添加特定业务要求');
    console.log('  --preview               预览模式，不保存文件');
    console.log('  --force                 强制覆盖已存在的文件');
    console.log('  --verbose               显示详细的生成过程');
    console.log('  --diff                  显示与现有 README 的差异（patch-readme 专用）');
    console.log('');
    
    console.log('🔧 模板类型:');
    console.log('  comprehensive    完整详细的 README（默认）');
    console.log('  simple           简洁版本的 README');
    console.log('  technical        技术导向的 README');
    console.log('');
    
    console.log('🌐 支持语言:');
    console.log('  zh-CN           中文（默认）');
    console.log('  en-US           英文');
    console.log('');
    
    console.log('💡 使用提示:');
    console.log('  • 生成器会自动分析项目结构、依赖关系和代码特征');
    console.log('  • 首次运行可能需要较长时间，请耐心等待');
    console.log('  • 建议在项目根目录运行以获得最佳分析效果');
    console.log('  • 使用 --preview 选项可以先查看效果再决定是否保存');
    console.log('  • patch-readme 命令支持渐进式更新，保持现有内容的连续性');
    console.log('  • 使用 --custom 选项可以添加特定的业务要求和优化指导');
    console.log('  • 自定义文件中的内容会被重点关注并融入最终的 README 中');
    console.log('  • 网络连接是必需的，因为需要调用 AI 服务');
    console.log('  • 输出路径支持目录，会自动生成带时间戳的文件名（如：readme-20241201143022.md）');
    console.log('');
    
    console.log('🐛 故障排除:');
    console.log('  • 如果生成失败，请检查网络连接');
    console.log('  • 确保项目目录包含有效的代码文件');
    console.log('  • 使用 --verbose 选项查看详细错误信息');
    console.log('  • 检查输出目录的写入权限');
    console.log('');
    
    console.log('📞 需要帮助?');
    console.log('  使用 "parser-agent --help" 查看所有可用命令');
  });

// 默认命令（保持向后兼容）
program
  .argument('[rootDir]', '项目根目录', process.cwd())
  .option('-o, --out <file>', '输出JSON文件路径', path.join(process.cwd(), 'data/entities.json'))
  .action(async (rootDir, options) => {
    // 如果没有指定子命令，则执行默认的提取行为
    if (!process.argv.slice(2).some(arg => ['extract', 'validate'].includes(arg))) {
      console.log('💡 使用默认提取模式，建议使用 "extract" 子命令以获得更多选项\n');

      try {
        const entities = await extractAllEntities(rootDir);

        // 输出到控制台（保持原有行为）
        console.log(JSON.stringify(entities, null, 2));

        // 确保输出目录存在
        const outputDir = path.dirname(options.out);
        ensureDirectoryExists(outputDir);

        // 保存到文件
        fs.writeFileSync(options.out, JSON.stringify(entities, null, 2));
        console.log(`\n✅ 已保存到: ${options.out}`);

      } catch (error) {
        console.error('❌ 提取失败:', error);
        process.exit(1);
      }
    }
  });

// 解析命令行参数
program.parse(process.argv); 