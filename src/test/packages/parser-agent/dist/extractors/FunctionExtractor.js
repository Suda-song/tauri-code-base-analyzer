"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionExtractor = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const ts_morph_1 = require("ts-morph");
const TypeUtils_1 = require("./TypeUtils");
const TSProjectManager_1 = require("./TSProjectManager");
class FunctionExtractor {
    static extract(filePath, rootDir) {
        const startTime = Date.now();
        console.log(`üîç [FunctionExtractor] ÂºÄÂßãÊèêÂèñ: ${filePath}`);
        // Ê£ÄÊü•ÁºìÂ≠ò
        const cached = this.tsManager.getCachedExtraction(filePath, this.EXTRACTOR_TYPE);
        if (cached) {
            console.log(`üí® [FunctionExtractor] ‰ΩøÁî®ÁºìÂ≠ò: ${filePath} (${cached.length} ‰∏™ÂÆû‰Ωì)`);
            return cached;
        }
        try {
            // ËØªÂèñÊñá‰ª∂ÂÜÖÂÆπ
            const content = fs_1.default.readFileSync(filePath, 'utf-8');
            // Ëé∑ÂèñÊ∫êÊñá‰ª∂
            const sourceFile = this.tsManager.getSourceFile(filePath, content);
            if (!sourceFile) {
                console.warn(`‚ö†Ô∏è  [FunctionExtractor] Êó†Ê≥ïÂàõÂª∫Ê∫êÊñá‰ª∂: ${filePath}`);
                return [];
            }
            const entities = [];
            const relativePath = path_1.default.relative(rootDir, filePath);
            // ÊèêÂèñÂêÑÁßçÂÆû‰ΩìÁ±ªÂûã
            this.extractFunctions(sourceFile, relativePath, entities);
            this.extractClasses(sourceFile, relativePath, entities);
            this.extractVariables(sourceFile, relativePath, entities);
            this.extractExports(sourceFile, relativePath, entities);
            const extractTime = Date.now() - startTime;
            console.log(`‚úÖ [FunctionExtractor] ${filePath} ÊèêÂèñÂÆåÊàê: ${entities.length} ‰∏™ÂÆû‰Ωì, ËÄóÊó∂: ${extractTime}ms`);
            // ÁºìÂ≠òÁªìÊûú
            this.tsManager.setCachedExtraction(filePath, this.EXTRACTOR_TYPE, entities);
            return entities;
        }
        catch (error) {
            console.error(`‚ùå [FunctionExtractor] ÊèêÂèñÂ§±Ë¥• ${filePath}: ${error.message}`);
            return [];
        }
    }
    /**
     * Ê∏ÖÁêÜÊèêÂèñÂô®ÁºìÂ≠ò
     */
    static clearCache() {
        this.tsManager.clearExtractorCache(this.EXTRACTOR_TYPE);
    }
    /**
     * Ëé∑ÂèñÊèêÂèñÂô®ÁºìÂ≠òÁªüËÆ°
     */
    static getCacheStats() {
        return this.tsManager.getCacheStats();
    }
    static extractFunctions(sourceFile, relativePath, entities) {
        const fileName = path_1.default.basename(relativePath, path_1.default.extname(relativePath));
        sourceFile.forEachChild((node) => {
            // Â§ÑÁêÜ export default function Âíå export function ËØ≠Ê≥ï
            if (node.getKind() === ts_morph_1.SyntaxKind.FunctionDeclaration) {
                const funcNode = node;
                const isExported = funcNode.hasExportKeyword();
                const isDefault = funcNode.hasDefaultKeyword();
                const funcName = funcNode.getName() || 'default';
                if (isExported && isDefault) {
                    // ÈªòËÆ§ÂØºÂá∫ÂáΩÊï∞ - Âà§Êñ≠ÊòØÂê¶‰∏∫ÁªÑ‰ª∂
                    const isComponent = TypeUtils_1.TypeUtils.isComponentFunction(funcNode, false);
                    entities.push({
                        id: isComponent ? `Component:${fileName}` : `Function:${fileName}`,
                        type: isComponent ? 'component' : 'function',
                        file: relativePath,
                        loc: {
                            start: node.getStartLineNumber(),
                            end: node.getEndLineNumber()
                        },
                        rawName: funcName === 'default' ? fileName : funcName
                    });
                }
                else if (isExported && !isDefault) {
                    // ÂëΩÂêçÂØºÂá∫ÂáΩÊï∞
                    const isComponent = TypeUtils_1.TypeUtils.isComponentFunction(funcNode, false);
                    entities.push({
                        id: isComponent ? `Component:${funcName}` : `Function:${funcName}`,
                        type: isComponent ? 'component' : 'function',
                        file: relativePath,
                        loc: {
                            start: node.getStartLineNumber(),
                            end: node.getEndLineNumber()
                        },
                        rawName: funcName
                    });
                }
            }
        });
    }
    static extractClasses(sourceFile, relativePath, entities) {
        const fileName = path_1.default.basename(relativePath, path_1.default.extname(relativePath));
        sourceFile.forEachChild((node) => {
            // Â§ÑÁêÜ export default class Âíå export class ËØ≠Ê≥ï
            if (node.getKind() === ts_morph_1.SyntaxKind.ClassDeclaration) {
                const classNode = node;
                const isExported = classNode.hasExportKeyword();
                const isDefault = classNode.hasDefaultKeyword();
                const className = classNode.getName() || 'default';
                if (isExported && isDefault) {
                    // ÈªòËÆ§ÂØºÂá∫Á±ª - Âà§Êñ≠ÊòØÂê¶‰∏∫ÁªÑ‰ª∂
                    const isComponent = TypeUtils_1.TypeUtils.isComponentClass(classNode, false);
                    const typeInfo = TypeUtils_1.TypeUtils.getClassTypeInfo(isComponent);
                    entities.push({
                        id: `${typeInfo.idPrefix}:${fileName}`,
                        type: typeInfo.type,
                        file: relativePath,
                        loc: {
                            start: node.getStartLineNumber(),
                            end: node.getEndLineNumber()
                        },
                        rawName: className === 'default' ? fileName : className
                    });
                }
                else if (isExported && !isDefault) {
                    // ÂëΩÂêçÂØºÂá∫Á±ª
                    const isComponent = TypeUtils_1.TypeUtils.isComponentClass(classNode, false);
                    const typeInfo = TypeUtils_1.TypeUtils.getClassTypeInfo(isComponent);
                    entities.push({
                        id: `${typeInfo.idPrefix}:${className}`,
                        type: typeInfo.type,
                        file: relativePath,
                        loc: {
                            start: node.getStartLineNumber(),
                            end: node.getEndLineNumber()
                        },
                        rawName: className
                    });
                }
            }
        });
    }
    static extractVariables(sourceFile, relativePath, entities) {
        const fileName = path_1.default.basename(relativePath, path_1.default.extname(relativePath));
        sourceFile.forEachChild((node) => {
            // Â§ÑÁêÜ export default const/var/let Âíå export const/var/let ËØ≠Ê≥ï
            if (node.getKind() === ts_morph_1.SyntaxKind.VariableStatement) {
                const varStatement = node;
                const isExported = varStatement.hasExportKeyword();
                const isDefault = varStatement.hasDefaultKeyword();
                if (varStatement.getDeclarations().length > 0) {
                    varStatement.getDeclarations().forEach(declaration => {
                        const varName = declaration.getName();
                        const isComponent = TypeUtils_1.TypeUtils.isComponentVariable(declaration, false);
                        const isFunction = TypeUtils_1.TypeUtils.isFunctionVariable(declaration);
                        const isConstant = TypeUtils_1.TypeUtils.isConstantVariable(declaration);
                        if (isExported && isDefault) {
                            // ÈªòËÆ§ÂØºÂá∫ÂèòÈáè
                            const typeInfo = TypeUtils_1.TypeUtils.getEntityTypeInfo(isComponent, isFunction, isConstant);
                            entities.push({
                                id: `${typeInfo.idPrefix}:${fileName}`,
                                type: typeInfo.type,
                                file: relativePath,
                                loc: {
                                    start: node.getStartLineNumber(),
                                    end: node.getEndLineNumber()
                                },
                                rawName: varName
                            });
                        }
                        else if (isExported && !isDefault) {
                            // ÂëΩÂêçÂØºÂá∫ÂèòÈáè
                            const typeInfo = TypeUtils_1.TypeUtils.getEntityTypeInfo(isComponent, isFunction, isConstant);
                            entities.push({
                                id: `${typeInfo.idPrefix}:${varName}`,
                                type: typeInfo.type,
                                file: relativePath,
                                loc: {
                                    start: node.getStartLineNumber(),
                                    end: node.getEndLineNumber()
                                },
                                rawName: varName
                            });
                        }
                    });
                }
            }
        });
    }
    static extractExports(sourceFile, relativePath, entities) {
        const fileName = path_1.default.basename(relativePath, path_1.default.extname(relativePath));
        sourceFile.forEachChild((node) => {
            // Â§ÑÁêÜ export = xxx Âíå export default xxx ËØ≠Ê≥ï
            if (node.getKind() === ts_morph_1.SyntaxKind.ExportAssignment) {
                const exportAssignment = node;
                const expression = exportAssignment.getExpression();
                const expressionKind = expression.getKindName();
                const expressionText = expression.getText();
                // Ê†πÊçÆÂØºÂá∫ÁöÑË°®ËææÂºèÁ±ªÂûãÊù•Âà§Êñ≠ÂÆû‰ΩìÁ±ªÂûã
                let entityType = 'function'; // ÈªòËÆ§ÂÄº
                let idPrefix = 'Function';
                if (expressionKind === 'ObjectLiteralExpression') {
                    // ÂØπË±°Â≠óÈù¢Èáè - Â∫îËØ•ÊòØÂèòÈáèÁ±ªÂûã
                    entityType = 'variable';
                    idPrefix = 'Variable';
                }
                else if (expressionKind === 'ArrayLiteralExpression') {
                    // Êï∞ÁªÑÂ≠óÈù¢Èáè - ‰πüÊòØÂèòÈáèÁ±ªÂûã
                    entityType = 'variable';
                    idPrefix = 'Variable';
                }
                else if (expressionKind === 'AsExpression') {
                    // Á±ªÂûãÊñ≠Ë®ÄË°®ËææÂºè - Ê£ÄÊü•ÂÜÖÈÉ®Ë°®ËææÂºè
                    const children = expression.getChildren();
                    if (children.length > 0) {
                        const innerExpression = children[0];
                        const innerKind = innerExpression.getKindName();
                        if (innerKind === 'ObjectLiteralExpression') {
                            entityType = 'variable';
                            idPrefix = 'Variable';
                        }
                        else if (innerKind === 'ArrayLiteralExpression') {
                            entityType = 'variable';
                            idPrefix = 'Variable';
                        }
                    }
                    // ÂÖ∂‰ªñÊÉÖÂÜµ‰øùÊåÅÈªòËÆ§ÁöÑfunctionÁ±ªÂûã
                }
                else if (expressionKind === 'ArrowFunction' || expressionKind === 'FunctionExpression') {
                    // ÁÆ≠Â§¥ÂáΩÊï∞ÊàñÂáΩÊï∞Ë°®ËææÂºè
                    const isComponent = /^[A-Z]/.test(fileName) && !TypeUtils_1.TypeUtils.isConstantVariable({ getName: () => fileName, getInitializer: () => ({ getText: () => expressionText }) });
                    if (isComponent) {
                        entityType = 'component';
                        idPrefix = 'Component';
                    }
                    else {
                        entityType = 'function';
                        idPrefix = 'Function';
                    }
                }
                else if (expressionKind === 'ClassExpression') {
                    // Á±ªË°®ËææÂºè
                    entityType = 'class';
                    idPrefix = 'Class';
                }
                else if (expressionKind === 'Identifier') {
                    // Ê†áËØÜÁ¨¶ - ÈúÄË¶ÅÊü•ÊâæÂéüÂßãÂ£∞Êòé
                    const identifierName = expression.getText();
                    const entityInfo = this.findLocalEntity(sourceFile, identifierName);
                    if (entityInfo) {
                        entityType = entityInfo.type;
                        idPrefix = entityInfo.idPrefix;
                    }
                }
                else if (/^['"`]/.test(expressionText) || /^\d/.test(expressionText) || /^(true|false|null|undefined)$/.test(expressionText)) {
                    // Â≠óÈù¢ÈáèÂÄº
                    entityType = 'variable';
                    idPrefix = 'Variable';
                }
                entities.push({
                    id: `${idPrefix}:${fileName}`,
                    type: entityType,
                    file: relativePath,
                    loc: {
                        start: node.getStartLineNumber(),
                        end: node.getEndLineNumber()
                    },
                    rawName: 'default'
                });
            }
            // Â§ÑÁêÜ export { ... } Êú¨Âú∞ÂØºÂá∫ËØ≠Ê≥ï
            if (node.getKind() === ts_morph_1.SyntaxKind.ExportDeclaration) {
                const exportDecl = node;
                const moduleSpecifier = exportDecl.getModuleSpecifier();
                if (!moduleSpecifier) {
                    // export { ... } - Êú¨Âú∞ÂØºÂá∫
                    const namedExports = exportDecl.getNamedExports();
                    namedExports.forEach(namedExport => {
                        const exportName = namedExport.getName();
                        const aliasName = namedExport.getAliasNode()?.getText() || exportName;
                        // Â∞ùËØïÂú®ÂΩìÂâçÊñá‰ª∂‰∏≠ÊâæÂà∞ÂØπÂ∫îÁöÑÂ£∞ÊòéÊù•Á°ÆÂÆöÁ±ªÂûã
                        const entityInfo = this.findLocalEntity(sourceFile, exportName);
                        if (entityInfo) {
                            entities.push({
                                id: `${entityInfo.idPrefix}:${aliasName}`,
                                type: entityInfo.type,
                                file: relativePath,
                                loc: {
                                    start: node.getStartLineNumber(),
                                    end: node.getEndLineNumber()
                                },
                                rawName: aliasName
                            });
                        }
                    });
                }
            }
        });
    }
    /**
     * Âú®ÂΩìÂâçÊñá‰ª∂‰∏≠Êü•ÊâæÊú¨Âú∞ÂÆû‰Ωì‰ø°ÊÅØ
     */
    static findLocalEntity(sf, entityName) {
        let result = null;
        sf.forEachChild((node) => {
            // Êü•ÊâæÂáΩÊï∞Â£∞Êòé
            if (node.getKind() === ts_morph_1.SyntaxKind.FunctionDeclaration) {
                const funcNode = node;
                if (funcNode.getName() === entityName) {
                    const isComponent = TypeUtils_1.TypeUtils.isComponentFunction(funcNode, false);
                    result = {
                        type: isComponent ? 'component' : 'function',
                        idPrefix: isComponent ? 'Component' : 'Function'
                    };
                }
            }
            // Êü•ÊâæÁ±ªÂ£∞Êòé
            if (node.getKind() === ts_morph_1.SyntaxKind.ClassDeclaration) {
                const classNode = node;
                if (classNode.getName() === entityName) {
                    const isComponent = TypeUtils_1.TypeUtils.isComponentClass(classNode, false);
                    const typeInfo = TypeUtils_1.TypeUtils.getClassTypeInfo(isComponent);
                    result = typeInfo;
                }
            }
            // Êü•ÊâæÂèòÈáèÂ£∞Êòé
            if (node.getKind() === ts_morph_1.SyntaxKind.VariableStatement) {
                const varStatement = node;
                varStatement.getDeclarations().forEach(decl => {
                    if (decl.getName() === entityName) {
                        const isComponent = TypeUtils_1.TypeUtils.isComponentVariable(decl, false);
                        const isFunction = TypeUtils_1.TypeUtils.isFunctionVariable(decl);
                        const isConstant = TypeUtils_1.TypeUtils.isConstantVariable(decl);
                        result = TypeUtils_1.TypeUtils.getEntityTypeInfo(isComponent, isFunction, isConstant);
                    }
                });
            }
        });
        return result;
    }
}
exports.FunctionExtractor = FunctionExtractor;
FunctionExtractor.EXTRACTOR_TYPE = 'FunctionExtractor';
FunctionExtractor.tsManager = (0, TSProjectManager_1.getTSProjectManager)();
