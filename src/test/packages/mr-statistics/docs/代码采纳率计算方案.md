# MR统计中的代码采纳率计算方案

## 1. 概述

本文档描述了MR统计功能中代码采纳率的计算方案，包括文件级别和代码行级别的采纳率计算方法，以及对多次Flow的处理逻辑。该方案旨在准确评估AI生成的代码在实际项目中的采纳情况，为开发者和管理者提供可靠的数据支持。

## 2. 主要改进点

### 2.1 文件匹配策略

系统采用多层级的文件匹配策略，按优先级依次为：

1. **精确路径匹配（匹配分数1.0）**：
   - 文件路径完全相同
   - 例如：`/src/components/Button.js` 与 `/src/components/Button.js`

2. **部分路径匹配（匹配分数0.9）**：
   - 一个路径是另一个的结尾或开头
   - 例如：`components/Button.js` 与 `/src/components/Button.js`

3. **文件名匹配（匹配分数0.8）**：
   - 仅文件名相同，路径不同
   - 例如：`/src/components/Button.js` 与 `/src/common/Button.js`

每种匹配都会产生一个匹配分数，只有当这个分数大于等于设定的阈值（默认0.7）时，才认为文件实际被匹配上。

### 2.2 代码内容匹配

除了路径匹配外，系统还会对文件内容进行匹配，确保真正的代码内容被采纳：

1. **代码行级匹配**：
   - 比较AI生成的代码行与MR文件的内容
   - 计算匹配的代码行比例
   - 生成内容匹配分数（0-1之间）

2. **综合评分**：
   - 如果代码内容匹配分数低，会降低整体匹配分数
   - 对于代码内容匹配率极低的情况（<30%），认为文件不匹配

### 2.3 多次Flow的处理

当同一个文件有多次Flow（AI多次生成或修改）时，系统采用以下处理方式：

1. **按创建时间降序排序**：
   - 查询文件变更记录时按created_at降序排序
   - 确保最新的变更记录优先处理

2. **文件级去重**：
   - 使用Map进行去重，同一文件路径只保留最新的记录
   - 记录去重前后的数量，便于调试和监控

3. **代码行级去重与合并**：
   - 从diff格式中精确提取每次变更的代码行
   - 对同一文件的所有变更记录中的代码行进行合并和去重
   - 使用Set确保每行代码只计算一次

4. **以最新变更为准**：
   - 使用最新的文件变更记录的匹配状态来计算采纳率
   - 基于去重后的代码行总数计算真实的采纳率

## 3. 计算逻辑

### 3.1 文件级采纳率

文件级采纳率表示"AI生成的文件有多少被采纳"，计算公式为：

```
fileAcceptanceRate = (includeAiCodeFiles / aiCodeFiles) * 100
```

其中：
- `includeAiCodeFiles`：匹配上的（被采纳的）AI生成文件数量
- `aiCodeFiles`：AI生成的文件总数量

### 3.2 代码行级采纳率

代码行级采纳率表示"AI生成的代码行有多少被采纳"，计算公式为：

```
mrCodeAcceptanceRate = (includeAiCodeLines / totalAiCodeLines) * 100
```

其中：
- `includeAiCodeLines`：被采纳的AI代码行数，按内容匹配比例计算
- `totalAiCodeLines`：AI生成的代码行总数（去重后）

对于每个匹配的文件，其采纳的代码行数是按比例计算的：
```
adoptedLines = aiFileUniqueLines * adoptionRate
```

这里的`adoptionRate`优先使用代码内容匹配分数，如果没有则默认使用0.8。

## 4. 实现细节

### 4.1 文件变更记录查询与去重

```typescript
// 查询与这些Flow相关的文件变更记录，按created_at降序排序确保可以找到最新的变更
const [rows] = await sequelize.query(`
  SELECT * FROM modular_dev_flow_file_changes
  WHERE flow_id IN (:flowIds)
  ORDER BY created_at DESC
`, {
  replacements: { flowIds },
  type: QueryTypes.SELECT
});

// 对变更记录进行去重，同一文件路径只保留最新的变更记录
const latestChangesByPath = new Map<string, FileChange>();

for (const change of allChanges) {
  const filePath = change.file_path;
  
  // 因为我们的查询已经按created_at降序排序，所以第一次遇到的记录就是最新的
  if (!latestChangesByPath.has(filePath)) {
    latestChangesByPath.set(filePath, change);
  }
}
```

### 4.2 代码行提取与去重

```typescript
// 从AI变更中提取具体的代码行
private extractChangedLines(change: FileChange): Set<string> {
  const changedLines = new Set<string>();
  
  try {
    // 优先使用change_details字段
    if (change.change_details) {
      const lines = change.change_details.split('\n');
      
      // 忽略diff头部
      let inHeader = true;
      
      for (const line of lines) {
        // 跳过diff头部
        if (inHeader) {
          if (line.startsWith('+++') || line.startsWith('---') || line.startsWith('@@')) {
            if (line.startsWith('@@')) {
              inHeader = false; // 下一行开始是内容
            }
            continue;
          } else {
            inHeader = false; // 不是头部格式，开始处理内容
          }
        }
        
        // 提取新增的代码行（去掉前缀'+'）
        if (line.startsWith('+') && !line.startsWith('+++')) {
          // 归一化代码行（去除前导和尾随空格）使比较更准确
          const trimmedLine = line.substring(1).trim();
          if (trimmedLine.length > 0) {
            changedLines.add(trimmedLine);
          }
        }
      }
    }
  } catch (error) {
    console.warn(`解析文件变更 ${change.file_path} 的代码行失败:`, error);
  }
  
  return changedLines;
}
```

### 4.3 代码采纳率计算

```typescript
// 按文件路径分组，处理同一文件的多次变更
const filePathGroups = new Map<string, FileChangeWithMatchStatus[]>();

// 分组处理
for (const file of matchedAiFiles) {
  const filePath = file.file_path;
  if (!filePathGroups.has(filePath)) {
    filePathGroups.set(filePath, []);
  }
  filePathGroups.get(filePath)!.push(file);
}

// 遍历每个唯一的文件路径
for (const [_, changes] of filePathGroups.entries()) {
  // 获取所有变更中唯一的代码行
  const allUniqueLines = new Set<string>();
  
  // 以最新的变更记录为基准（前面已经按created_at降序排序）
  const latestChange = changes[0];
  const matchStatus = latestChange.matchStatus;
  
  // 合并同一文件所有变更的代码行
  for (const change of changes) {
    const changedLines = this.extractChangedLines(change);
    changedLines.forEach(line => allUniqueLines.add(line));
  }
  
  // 计算这个文件的总代码行数（去重后）
  const aiFileUniqueLines = allUniqueLines.size;
  totalAiCodeLines += aiFileUniqueLines;
  
  // 如果文件匹配，计算被采纳的代码行数
  if (matchStatus.isMatched) {
    let adoptionRate = 0.8; // 默认采纳率
    
    // 如果有代码内容匹配分数，使用它作为采纳率
    if (matchStatus.codeMatchScore !== undefined && matchStatus.codeMatchScore > 0) {
      adoptionRate = matchStatus.codeMatchScore;
    }
    
    // 按内容匹配率比例计算采纳的行数
    includeAiCodeLines += Math.round(aiFileUniqueLines * adoptionRate);
  }
}
```

## 5. 优势和效果

1. **更准确的统计数据**：
   - 不仅考虑文件是否存在，还考虑代码内容是否真的被采用
   - 避免因为文件路径相似但代码完全不同而导致的统计错误

2. **更精确的多次Flow处理**：
   - 正确处理同一文件多次修改的情况
   - 以最新的变更为准，避免重复统计
   - 通过代码行去重保证了统计数据的准确性

3. **更细粒度的匹配**：
   - 从文件级匹配提升到代码行级匹配
   - 能够反映代码被部分采纳的情况，如重构或修改后的采纳

4. **更透明的计算过程**：
   - 提供更多调试信息和中间计算结果
   - 便于理解统计数据的来源和计算逻辑

## 6. 注意事项

1. **性能考虑**：
   - 当文件数量较多时，内容匹配可能会消耗较多资源
   - 针对大型项目可能需要进一步优化

2. **阈值调整**：
   - 可以根据项目需要调整文件匹配和代码内容匹配的阈值
   - 默认值：文件匹配阈值0.7，代码内容匹配阈值0.6

3. **特殊情况处理**：
   - 对于二进制文件或特殊格式文件，内容匹配可能不适用
   - 系统会退回到基于路径的匹配策略