"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWorkspacePackageMappings = getWorkspacePackageMappings;
exports.getWorkspaceChangedFiles = getWorkspaceChangedFiles;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
/**
 * Ëé∑ÂèñÂΩìÂâçÂ∑•Á®ã‰æùËµñÁöÑÊâÄÊúâworkspaceÂåÖË∑ØÂæÑÊò†Â∞Ñ
 */
function getWorkspacePackageMappings(projectRoot, options = {}) {
    const { includeDevDependencies = true, includePeerDependencies = false, maxDepth = 3 } = options;
    // Á°Æ‰øùprojectRootÊòØÁªùÂØπË∑ØÂæÑ
    const absoluteProjectRoot = path_1.default.isAbsolute(projectRoot) ? projectRoot : path_1.default.resolve(process.cwd(), projectRoot);
    console.log(`üîç ÂºÄÂßãÂàÜÊûêworkspaceÂåÖÊò†Â∞Ñ (È°πÁõÆ: ${projectRoot} -> ${absoluteProjectRoot})`);
    try {
        // 1. ËØªÂèñÈ°πÁõÆÁöÑpackage.json
        const packageJsonPath = path_1.default.join(absoluteProjectRoot, 'package.json');
        if (!fs_1.default.existsSync(packageJsonPath)) {
            console.warn(`‚ùå È°πÁõÆpackage.json‰∏çÂ≠òÂú®: ${packageJsonPath}`);
            return [];
        }
        const packageJson = JSON.parse(fs_1.default.readFileSync(packageJsonPath, 'utf-8'));
        console.log(`üì¶ ÂàÜÊûêÈ°πÁõÆ: ${packageJson.name || 'unknown'}`);
        // 2. Êî∂ÈõÜÊâÄÊúâworkspace‰æùËµñ
        const workspaceDeps = new Set();
        // Êî∂ÈõÜdependencies
        if (packageJson.dependencies) {
            Object.entries(packageJson.dependencies).forEach(([name, version]) => {
                if (typeof version === 'string' && version.startsWith('workspace:')) {
                    workspaceDeps.add(name);
                    console.log(`üìå ÂèëÁé∞workspace‰æùËµñ: ${name} (${version})`);
                }
            });
        }
        // Êî∂ÈõÜdevDependencies
        if (includeDevDependencies && packageJson.devDependencies) {
            Object.entries(packageJson.devDependencies).forEach(([name, version]) => {
                if (typeof version === 'string' && version.startsWith('workspace:')) {
                    workspaceDeps.add(name);
                    console.log(`üîß ÂèëÁé∞workspaceÂºÄÂèë‰æùËµñ: ${name} (${version})`);
                }
            });
        }
        // Êî∂ÈõÜpeerDependencies
        if (includePeerDependencies && packageJson.peerDependencies) {
            Object.entries(packageJson.peerDependencies).forEach(([name, version]) => {
                if (typeof version === 'string' && version.startsWith('workspace:')) {
                    workspaceDeps.add(name);
                    console.log(`ü§ù ÂèëÁé∞workspace peer‰æùËµñ: ${name} (${version})`);
                }
            });
        }
        // Ê£ÄÊü•dependenciesMeta‰∏≠ÁöÑinjectedÂåÖ
        if (packageJson.dependenciesMeta) {
            Object.entries(packageJson.dependenciesMeta).forEach(([name, meta]) => {
                if (meta && meta.injected) {
                    workspaceDeps.add(name);
                    console.log(`üíâ ÂèëÁé∞injected‰æùËµñ: ${name}`);
                }
            });
        }
        if (workspaceDeps.size === 0) {
            console.log('üì≠ Êú™ÂèëÁé∞‰ªª‰Ωïworkspace‰æùËµñ');
            return [];
        }
        console.log(`üéØ ÂÖ±ÂèëÁé∞ ${workspaceDeps.size} ‰∏™workspace‰æùËµñ`);
        // 3. Êü•ÊâæworkspaceÊ†πÁõÆÂΩï
        const workspaceRoot = findWorkspaceRoot(absoluteProjectRoot);
        if (!workspaceRoot) {
            console.warn('‚ùå Êú™ÊâæÂà∞workspaceÊ†πÁõÆÂΩï');
            return [];
        }
        console.log(`üè† workspaceÊ†πÁõÆÂΩï: ${workspaceRoot}`);
        // 4. ÊûÑÂª∫ÂåÖÊò†Â∞Ñ
        const packageMappings = [];
        const workspacePackageMap = buildWorkspacePackageMap(workspaceRoot, maxDepth);
        for (const packageName of workspaceDeps) {
            const packagePath = workspacePackageMap.get(packageName);
            if (packagePath) {
                const relativePath = path_1.default.relative(absoluteProjectRoot, packagePath);
                packageMappings.push({
                    name: packageName,
                    path: packagePath,
                    relativePath
                });
                console.log(`‚úÖ Êò†Â∞ÑÊàêÂäü: ${packageName} -> ${relativePath}`);
            }
            else {
                console.warn(`‚ö†Ô∏è  Êú™ÊâæÂà∞ÂåÖË∑ØÂæÑ: ${packageName}`);
            }
        }
        console.log(`üéâ workspaceÂåÖÊò†Â∞ÑÂÆåÊàêÔºåÂÖ±Êò†Â∞Ñ ${packageMappings.length}/${workspaceDeps.size} ‰∏™ÂåÖ`);
        return packageMappings;
    }
    catch (error) {
        console.error(`‚ùå workspaceÂåÖÊò†Â∞ÑÂ§±Ë¥•:`, error);
        return [];
    }
}
/**
 * Ëé∑ÂèñworkspaceÂåÖ‰∏≠ÂèòÊõ¥ÁöÑÊñá‰ª∂ÂàóË°®
 */
function getWorkspaceChangedFiles(projectRoot, gitChangedFiles, options = {}) {
    console.log(`üîÑ ÂàÜÊûêworkspaceÂåÖ‰∏≠ÁöÑÂèòÊõ¥Êñá‰ª∂...`);
    // Á°Æ‰øùprojectRootÊòØÁªùÂØπË∑ØÂæÑ
    const absoluteProjectRoot = path_1.default.isAbsolute(projectRoot) ? projectRoot : path_1.default.resolve(process.cwd(), projectRoot);
    console.log(`üìã ËæìÂÖ•ÂèÇÊï∞:`);
    console.log(`  - projectRoot: ${projectRoot} -> ${absoluteProjectRoot}`);
    console.log(`  - gitChangedFilesÊï∞Èáè: ${gitChangedFiles.length}`);
    console.log(`  - gitChangedFilesÂâç5‰∏™: ${gitChangedFiles.slice(0, 5).join(', ')}`);
    const workspacePackages = getWorkspacePackageMappings(absoluteProjectRoot, options);
    if (workspacePackages.length === 0) {
        console.log('üì≠ Êó†workspaceÂåÖÔºåËøîÂõûÁ©∫ÂàóË°®');
        return [];
    }
    console.log(`üì¶ ÊâæÂà∞ ${workspacePackages.length} ‰∏™workspaceÂåÖ:`);
    workspacePackages.forEach(pkg => {
        console.log(`  - ${pkg.name}: ${pkg.path}`);
    });
    const workspaceChangedFiles = [];
    for (const pkg of workspacePackages) {
        console.log(`üîç Ê£ÄÊü•workspaceÂåÖ: ${pkg.name} (${pkg.path})`);
        // Êü•ÊâæËØ•workspaceÂåÖ‰∏≠ÁöÑÂèòÊõ¥Êñá‰ª∂
        const packageChangedFiles = gitChangedFiles.filter(file => {
            const absoluteFile = path_1.default.isAbsolute(file) ? file : path_1.default.resolve(absoluteProjectRoot, file);
            const isInPackage = absoluteFile.startsWith(pkg.path + path_1.default.sep) || absoluteFile === pkg.path;
            if (isInPackage) {
                console.log(`  ‚úÖ ÂåπÈÖçÊñá‰ª∂: ${file} -> ${absoluteFile}`);
            }
            return isInPackage;
        });
        console.log(`  üìä ${pkg.name} ‰∏≠ÁöÑÂèòÊõ¥Êñá‰ª∂Êï∞Èáè: ${packageChangedFiles.length}`);
        if (packageChangedFiles.length > 0) {
            console.log(`üìù Âú® ${pkg.name} ‰∏≠ÂèëÁé∞ ${packageChangedFiles.length} ‰∏™ÂèòÊõ¥Êñá‰ª∂:`);
            packageChangedFiles.forEach(file => {
                console.log(`  - ${file}`);
            });
            workspaceChangedFiles.push(...packageChangedFiles);
        }
        else {
            console.log(`  üì≠ ${pkg.name} ‰∏≠Êó†ÂèòÊõ¥Êñá‰ª∂`);
        }
    }
    console.log(`üéØ workspaceÂåÖÂèòÊõ¥Êñá‰ª∂ÊÄªÊï∞: ${workspaceChangedFiles.length}`);
    if (workspaceChangedFiles.length > 0) {
        console.log(`üìã workspaceÂèòÊõ¥Êñá‰ª∂ÂàóË°®:`);
        workspaceChangedFiles.forEach(file => console.log(`  - ${file}`));
    }
    return workspaceChangedFiles;
}
/**
 * Âêë‰∏äÊü•ÊâæworkspaceÈÖçÁΩÆÊñá‰ª∂
 */
function findWorkspaceRoot(startDir) {
    let currentDir = startDir;
    while (currentDir !== path_1.default.dirname(currentDir)) {
        // Ê£ÄÊü•pnpm-workspace.yaml
        const pnpmWorkspacePath = path_1.default.join(currentDir, 'pnpm-workspace.yaml');
        if (fs_1.default.existsSync(pnpmWorkspacePath)) {
            return currentDir;
        }
        // Ê£ÄÊü•package.jsonÁöÑworkspacesÂ≠óÊÆµ
        const packageJsonPath = path_1.default.join(currentDir, 'package.json');
        if (fs_1.default.existsSync(packageJsonPath)) {
            try {
                const packageJson = JSON.parse(fs_1.default.readFileSync(packageJsonPath, 'utf-8'));
                if (packageJson.workspaces) {
                    return currentDir;
                }
            }
            catch (error) {
                // ÂøΩÁï•Ëß£ÊûêÈîôËØØ
            }
        }
        currentDir = path_1.default.dirname(currentDir);
    }
    return null;
}
/**
 * ÊûÑÂª∫workspaceÂåÖÊò†Â∞Ñ
 */
function buildWorkspacePackageMap(workspaceRoot, maxDepth = 3) {
    const packageMap = new Map();
    try {
        console.log(`üî® ÊûÑÂª∫workspaceÂåÖÊò†Â∞Ñ (Ê†πÁõÆÂΩï: ${workspaceRoot}, ÊúÄÂ§ßÊ∑±Â∫¶: ${maxDepth})`);
        // Ëé∑Âèñworkspace patterns
        const workspacePatterns = getWorkspacePatterns(workspaceRoot);
        console.log(`üìã workspaceÊ®°Âºè: ${JSON.stringify(workspacePatterns)}`);
        let totalFound = 0;
        for (const pattern of workspacePatterns) {
            console.log(`üîç Â§ÑÁêÜÊ®°Âºè: ${pattern}`);
            const possiblePaths = resolveWorkspacePattern(workspaceRoot, pattern, maxDepth);
            console.log(`  Ëß£ÊûêÂá∫ ${possiblePaths.length} ‰∏™Ë∑ØÂæÑ`);
            for (const possiblePath of possiblePaths) {
                if (isValidWorkspacePackage(possiblePath)) {
                    const packageJsonPath = path_1.default.join(possiblePath, 'package.json');
                    try {
                        const packageJson = JSON.parse(fs_1.default.readFileSync(packageJsonPath, 'utf-8'));
                        if (packageJson.name) {
                            packageMap.set(packageJson.name, possiblePath);
                            console.log(`  üì¶ ${packageJson.name} -> ${path_1.default.relative(workspaceRoot, possiblePath)}`);
                            totalFound++;
                        }
                    }
                    catch (error) {
                        console.warn(`  ‚ö†Ô∏è  Ëß£Êûê ${packageJsonPath} Â§±Ë¥•: ${error}`);
                    }
                }
            }
        }
        console.log(`‚úÖ ÂåÖÊò†Â∞ÑÊûÑÂª∫ÂÆåÊàêÔºåÊâæÂà∞ ${totalFound} ‰∏™workspaceÂåÖ`);
    }
    catch (error) {
        console.warn(`‚ùå ÊûÑÂª∫ÂåÖÊò†Â∞ÑÂ§±Ë¥•: ${error}`);
    }
    return packageMap;
}
/**
 * Ëé∑Âèñworkspace patterns
 */
function getWorkspacePatterns(rootDir) {
    const patterns = [];
    // Ê£ÄÊü•pnpm-workspace.yaml
    const pnpmWorkspacePath = path_1.default.join(rootDir, 'pnpm-workspace.yaml');
    if (fs_1.default.existsSync(pnpmWorkspacePath)) {
        try {
            const yamlContent = fs_1.default.readFileSync(pnpmWorkspacePath, 'utf-8');
            const lines = yamlContent.split('\n');
            let inPackagesSection = false;
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine === 'packages:') {
                    inPackagesSection = true;
                    continue;
                }
                if (inPackagesSection) {
                    if (trimmedLine && !trimmedLine.startsWith('-') && !trimmedLine.startsWith(' ') && trimmedLine.includes(':')) {
                        inPackagesSection = false;
                        continue;
                    }
                    if (trimmedLine.startsWith('-')) {
                        const pattern = trimmedLine.replace(/^\s*-\s*['"]?|['"]?\s*$/g, '');
                        if (pattern) {
                            patterns.push(pattern);
                        }
                    }
                }
            }
        }
        catch (error) {
            console.warn('Ëß£Êûêpnpm-workspace.yamlÂ§±Ë¥•:', error);
        }
    }
    // Ê£ÄÊü•package.jsonÁöÑworkspacesÂ≠óÊÆµ
    const packageJsonPath = path_1.default.join(rootDir, 'package.json');
    if (fs_1.default.existsSync(packageJsonPath)) {
        try {
            const packageJson = JSON.parse(fs_1.default.readFileSync(packageJsonPath, 'utf-8'));
            if (packageJson.workspaces) {
                if (Array.isArray(packageJson.workspaces)) {
                    patterns.push(...packageJson.workspaces);
                }
                else if (packageJson.workspaces.packages) {
                    patterns.push(...packageJson.workspaces.packages);
                }
            }
        }
        catch (error) {
            console.warn('Ëß£Êûêpackage.json workspacesÂ§±Ë¥•:', error);
        }
    }
    // ÈªòËÆ§Ê®°Âºè
    if (patterns.length === 0) {
        patterns.push('packages/*', 'packages/*/*', 'apps/*', 'libs/*');
    }
    return patterns;
}
/**
 * Ëß£Êûêworkspace pattern
 */
function resolveWorkspacePattern(rootDir, pattern, maxDepth = 3) {
    const results = [];
    try {
        console.log(`ÂºÄÂßãËß£ÊûêworkspaceÊ®°Âºè: ${pattern}, Âü∫‰∫éÊ†πÁõÆÂΩï: ${rootDir}`);
        if (pattern.includes('*')) {
            // Â§ÑÁêÜÂêÑÁßçglobÊ®°Âºè
            const candidatePaths = expandGlobPattern(pattern, rootDir);
            // ËøáÊª§Âá∫ÁúüÊ≠£ÁöÑworkspaceÂåÖ
            results.push(...filterValidWorkspacePackages(candidatePaths));
        }
        else {
            // Áõ¥Êé•Ë∑ØÂæÑÔºåÂü∫‰∫éÊ†πÁõÆÂΩïËß£Êûê
            const fullPath = path_1.default.resolve(rootDir, pattern);
            if (isValidWorkspacePackage(fullPath)) {
                results.push(fullPath);
                console.log(`Áõ¥Êé•Ë∑ØÂæÑËß£ÊûêÊàêÂäü: ${pattern} -> ${fullPath}`);
            }
        }
    }
    catch (error) {
        console.warn(`Ëß£ÊûêworkspaceÊ®°Âºè ${pattern} Â§±Ë¥•:`, error);
    }
    console.log(`Ê®°Âºè ${pattern} Ëß£ÊûêÁªìÊûúÊï∞Èáè: ${results.length}`);
    if (results.length > 0) {
        console.log(`ÊúâÊïàworkspaceÂåÖ: ${results.slice(0, 3).join(', ')}${results.length > 3 ? '...' : ''}`);
    }
    return results;
}
/**
 * Â±ïÂºÄglobÊ®°ÂºèÔºàÊîØÊåÅ *, **, /** Á≠âÂ§çÊùÇÊ®°ÂºèÔºâ
 */
function expandGlobPattern(pattern, basePath) {
    const results = [];
    // È¢ÑÂ§ÑÁêÜÊ®°ÂºèÔºöÊ†áÂáÜÂåñË∑ØÂæÑÂàÜÈöîÁ¨¶
    const normalizedPattern = pattern.replace(/\\/g, '/');
    // Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´ÈÄíÂΩíÈÄöÈÖçÁ¨¶ **
    if (normalizedPattern.includes('**')) {
        results.push(...expandRecursivePattern(normalizedPattern, basePath));
    }
    else {
        // Â§ÑÁêÜÁÆÄÂçïÁöÑÂçïÂ±ÇÈÄöÈÖçÁ¨¶
        results.push(...expandSimplePattern(normalizedPattern, basePath));
    }
    return results;
}
/**
 * Â±ïÂºÄÈÄíÂΩíÊ®°ÂºèÔºàÂåÖÂê´ ** ÁöÑÊ®°ÂºèÔºâ
 */
function expandRecursivePattern(pattern, basePath) {
    const results = [];
    // Â§ÑÁêÜÂΩ¢Â¶Ç packages/**, packages/**/* Á≠âÊ®°Âºè
    if (pattern === '**' || pattern === '**/*') {
        // ÈÄíÂΩíÊü•ÊâæÊâÄÊúâÁõÆÂΩï
        results.push(...findAllDirectories(basePath, true));
    }
    else if (pattern.startsWith('**/')) {
        // ÂΩ¢Â¶Ç **/subpath ÁöÑÊ®°Âºè
        const subPattern = pattern.substring(3);
        const allDirs = findAllDirectories(basePath, true);
        for (const dir of allDirs) {
            const subResults = expandGlobPattern(subPattern, dir);
            results.push(...subResults);
        }
    }
    else if (pattern.endsWith('/**')) {
        // ÂΩ¢Â¶Ç packages/** ÁöÑÊ®°Âºè
        const prefix = pattern.substring(0, pattern.length - 3);
        const prefixPath = path_1.default.join(basePath, prefix);
        if (fs_1.default.existsSync(prefixPath)) {
            results.push(...findAllDirectories(prefixPath, true));
        }
    }
    else if (pattern.endsWith('/**/*')) {
        // ÂΩ¢Â¶Ç packages/**/* ÁöÑÊ®°Âºè
        const prefix = pattern.substring(0, pattern.length - 5);
        const prefixPath = path_1.default.join(basePath, prefix);
        if (fs_1.default.existsSync(prefixPath)) {
            results.push(...findAllDirectories(prefixPath, true));
        }
    }
    else {
        // ÂåÖÂê´ ** ÁöÑÂ§çÊùÇÊ®°ÂºèÔºåÊåâ ** ÂàÜÂâ≤Â§ÑÁêÜ
        const parts = pattern.split('**');
        if (parts.length === 2) {
            const [prefix, suffix] = parts;
            let searchPaths = [basePath];
            // Â§ÑÁêÜÂâçÁºÄ
            if (prefix && prefix !== '/') {
                const cleanPrefix = prefix.replace(/\/$/, '');
                searchPaths = [path_1.default.join(basePath, cleanPrefix)];
            }
            // ÈÄíÂΩíÊü•ÊâæÊâÄÊúâÁõÆÂΩï
            const allDirs = [];
            for (const searchPath of searchPaths) {
                if (fs_1.default.existsSync(searchPath)) {
                    allDirs.push(...findAllDirectories(searchPath, true));
                }
            }
            // Â§ÑÁêÜÂêéÁºÄ
            if (suffix && suffix !== '/' && suffix !== '/*') {
                const cleanSuffix = suffix.replace(/^\//, '');
                for (const dir of allDirs) {
                    const subResults = expandGlobPattern(cleanSuffix, dir);
                    results.push(...subResults);
                }
            }
            else {
                results.push(...allDirs);
            }
        }
    }
    return results;
}
/**
 * Â±ïÂºÄÁÆÄÂçïÊ®°ÂºèÔºàÂè™ÂåÖÂê´ÂçïÂ±ÇÈÄöÈÖçÁ¨¶ * ÁöÑÊ®°ÂºèÔºâ
 */
function expandSimplePattern(pattern, basePath) {
    const results = [];
    const parts = pattern.split('/');
    let currentPaths = [basePath];
    for (const part of parts) {
        if (part === '*') {
            const newPaths = [];
            for (const currentPath of currentPaths) {
                if (fs_1.default.existsSync(currentPath)) {
                    try {
                        const entries = fs_1.default.readdirSync(currentPath);
                        for (const entry of entries) {
                            // Ë∑≥Ëøá‰∏çÂ∫îËØ•ÂåÖÂê´workspaceÂåÖÁöÑÁõÆÂΩï
                            if (shouldSkipDirectory(entry)) {
                                continue;
                            }
                            const entryPath = path_1.default.join(currentPath, entry);
                            if (fs_1.default.statSync(entryPath).isDirectory()) {
                                newPaths.push(entryPath);
                            }
                        }
                    }
                    catch (error) {
                        console.warn(`ËØªÂèñÁõÆÂΩïÂ§±Ë¥•: ${currentPath}`);
                    }
                }
            }
            currentPaths = newPaths;
        }
        else if (part !== '') {
            currentPaths = currentPaths.map(p => path_1.default.join(p, part));
        }
    }
    results.push(...currentPaths.filter(p => fs_1.default.existsSync(p) && fs_1.default.statSync(p).isDirectory()));
    return results;
}
/**
 * ÈÄíÂΩíÊü•ÊâæÁõÆÂΩï‰∏ãÁöÑÊâÄÊúâÂ≠êÁõÆÂΩï
 */
function findAllDirectories(rootPath, includeRoot = false) {
    const results = [];
    if (!fs_1.default.existsSync(rootPath) || !fs_1.default.statSync(rootPath).isDirectory()) {
        return results;
    }
    if (includeRoot) {
        results.push(rootPath);
    }
    try {
        const entries = fs_1.default.readdirSync(rootPath);
        for (const entry of entries) {
            // Ë∑≥Ëøá‰∏çÂ∫îËØ•ÂåÖÂê´workspaceÂåÖÁöÑÁõÆÂΩï
            if (shouldSkipDirectory(entry)) {
                continue;
            }
            const entryPath = path_1.default.join(rootPath, entry);
            const stat = fs_1.default.statSync(entryPath);
            if (stat.isDirectory()) {
                results.push(entryPath);
                // ÈÄíÂΩíÊü•ÊâæÂ≠êÁõÆÂΩïÔºà‰ΩÜ‰∏çË¶ÅÈÄíÂΩíÂ§™Ê∑±ÔºåÈÅøÂÖçÊÄßËÉΩÈóÆÈ¢òÔºâ
                const depth = entryPath.split(path_1.default.sep).length - rootPath.split(path_1.default.sep).length;
                if (depth < 3) { // ÈôêÂà∂ÈÄíÂΩíÊ∑±Â∫¶
                    results.push(...findAllDirectories(entryPath, false));
                }
            }
        }
    }
    catch (error) {
        console.warn(`ËØªÂèñÁõÆÂΩïÂ§±Ë¥•: ${rootPath}`, error);
    }
    return results;
}
/**
 * Ê£ÄÊü•ÊòØÂê¶Â∫îËØ•Ë∑≥ËøáÊüê‰∏™ÁõÆÂΩï
 */
function shouldSkipDirectory(dirName) {
    const excludedDirs = [
        'node_modules',
        '.git',
        '.vscode',
        '.idea',
        'dist',
        'build',
        'coverage',
        'tmp',
        'temp',
        '.DS_Store',
        'logs',
        '.next',
        '.nuxt',
        'out',
        'target',
        'bin',
        'obj'
    ];
    return excludedDirs.includes(dirName) || dirName.startsWith('.');
}
/**
 * ËøáÊª§Âá∫ÊúâÊïàÁöÑworkspaceÂåÖ
 */
function filterValidWorkspacePackages(candidatePaths) {
    const validPackages = [];
    for (const candidatePath of candidatePaths) {
        if (isValidWorkspacePackage(candidatePath)) {
            validPackages.push(candidatePath);
        }
    }
    return validPackages;
}
/**
 * Ê£ÄÊü•ÁõÆÂΩïÊòØÂê¶‰∏∫ÊúâÊïàÁöÑworkspaceÂåÖ
 */
function isValidWorkspacePackage(dirPath) {
    try {
        // 1. Ê£ÄÊü•ÁõÆÂΩïÊòØÂê¶Â≠òÂú®
        if (!fs_1.default.existsSync(dirPath)) {
            return false;
        }
        const stat = fs_1.default.statSync(dirPath);
        if (!stat.isDirectory()) {
            return false;
        }
        // 2. ËøáÊª§Êéâ‰∏çÂ∫îËØ•ÊòØworkspaceÂåÖÁöÑÁõÆÂΩï
        const dirName = path_1.default.basename(dirPath);
        if (shouldSkipDirectory(dirName)) {
            return false;
        }
        // 3. Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´package.json
        const packageJsonPath = path_1.default.join(dirPath, 'package.json');
        if (!fs_1.default.existsSync(packageJsonPath)) {
            return false;
        }
        // 4. Ê£ÄÊü•package.jsonÊòØÂê¶ÊúâÊïà‰∏îÂåÖÂê´nameÂ≠óÊÆµ
        try {
            const packageJsonContent = fs_1.default.readFileSync(packageJsonPath, 'utf-8');
            const packageJson = JSON.parse(packageJsonContent);
            // ÂøÖÈ°ªÊúânameÂ≠óÊÆµ
            if (!packageJson.name || typeof packageJson.name !== 'string') {
                console.log(`Ë∑≥ËøáÊó†ÊïàÂåÖ(Áº∫Â∞ënameÂ≠óÊÆµ): ${dirPath}`);
                return false;
            }
            // ËøáÊª§Êéâ‰∏Ä‰∫õÊòéÊòæ‰∏çÊòØÂ∫îÁî®ÂåÖÁöÑÂåÖ
            const excludedNames = [
                'eslint-config',
                'prettier-config',
                'tsconfig'
            ];
            const isExcludedName = excludedNames.some(excluded => packageJson.name.includes(excluded));
            if (isExcludedName) {
                console.log(`Ë∑≥ËøáÈÖçÁΩÆÂåÖ: ${packageJson.name} at ${dirPath}`);
                return false;
            }
            // 5. ÂèØÈÄâÔºöÊ£ÄÊü•ÊòØÂê¶ÊúâÂ∏∏ËßÅÁöÑÈ°πÁõÆÊñá‰ª∂ÁªìÊûÑ
            const hasSourceFiles = hasSourceFilesInDirectory(dirPath);
            if (!hasSourceFiles) {
                console.log(`Ë∑≥ËøáÊó†Ê∫êÁ†ÅÂåÖ: ${packageJson.name} at ${dirPath}`);
                return false;
            }
            console.log(`ÂèëÁé∞ÊúâÊïàworkspaceÂåÖ: ${packageJson.name} at ${dirPath}`);
            return true;
        }
        catch (error) {
            console.log(`Ë∑≥ËøáÊó†Êïàpackage.json: ${dirPath} - ${error.message}`);
            return false;
        }
    }
    catch (error) {
        console.warn(`Ê£ÄÊü•workspaceÂåÖÂ§±Ë¥•: ${dirPath} - ${error.message}`);
        return false;
    }
}
/**
 * Ê£ÄÊü•ÁõÆÂΩïÊòØÂê¶ÂåÖÂê´Ê∫ê‰ª£Á†ÅÊñá‰ª∂
 */
function hasSourceFilesInDirectory(dirPath) {
    const commonSourceDirs = ['src', 'lib', 'app', 'components', 'pages', 'views'];
    const commonSourceFiles = [
        'index.js', 'index.ts', 'index.jsx', 'index.tsx', 'index.vue',
        'main.js', 'main.ts', 'app.js', 'app.ts', 'server.js', 'server.ts'
    ];
    try {
        // Ê£ÄÊü•ÊòØÂê¶ÊúâÊ∫êÁ†ÅÁõÆÂΩï
        for (const sourceDir of commonSourceDirs) {
            const sourceDirPath = path_1.default.join(dirPath, sourceDir);
            if (fs_1.default.existsSync(sourceDirPath) && fs_1.default.statSync(sourceDirPath).isDirectory()) {
                return true;
            }
        }
        // Ê£ÄÊü•Ê†πÁõÆÂΩïÊòØÂê¶ÊúâÂ∏∏ËßÅÁöÑÂÖ•Âè£Êñá‰ª∂
        for (const sourceFile of commonSourceFiles) {
            const sourceFilePath = path_1.default.join(dirPath, sourceFile);
            if (fs_1.default.existsSync(sourceFilePath)) {
                return true;
            }
        }
        // Ê£ÄÊü•ÊòØÂê¶Ëá≥Â∞ëÊúâ‰∏Ä‰∫õJS/TS/VueÊñá‰ª∂
        const entries = fs_1.default.readdirSync(dirPath);
        for (const entry of entries) {
            const entryPath = path_1.default.join(dirPath, entry);
            if (fs_1.default.statSync(entryPath).isFile()) {
                const ext = path_1.default.extname(entry).toLowerCase();
                if (['.js', '.ts', '.jsx', '.tsx', '.vue', '.json'].includes(ext)) {
                    return true;
                }
            }
        }
        return false;
    }
    catch (error) {
        return false;
    }
}
//# sourceMappingURL=workspace-mapper.js.map